<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数字签名</title>
      <link href="/2023/03/27/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
      <url>/2023/03/27/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="数字签名（DSA）"><a href="#数字签名（DSA）" class="headerlink" title="数字签名（DSA）"></a>数字签名（DSA）</h1><p>数字签名就是签名方用自己的私钥签名，验证方用签名方的公钥验证。</p><h2 id="1-椭圆曲线数字签名（ECDSA）"><a href="#1-椭圆曲线数字签名（ECDSA）" class="headerlink" title="1 椭圆曲线数字签名（ECDSA）"></a>1 椭圆曲线数字签名（ECDSA）</h2><p><a href="https://www.instructables.com/Understanding-how-ECDSA-protects-your-data/">参考链接：Understanding How ECDSA Protects Your Data</a></p><h3 id="1-1-什么是ECDSA"><a href="#1-1-什么是ECDSA" class="headerlink" title="1.1 什么是ECDSA"></a>1.1 什么是ECDSA</h3><p><code>ECDSA</code>是 <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">Elliptic Curve Digital Signature Algorithm</a>（椭圆曲线数字签名）的简称，主要用于对数据（比如一个文件）创建数字签名，以便于你在不破坏它的安全性的前提下对它的真实性进行验证。可以将它想象成一个实际的签名，你可以识别部分人的签名，但是你无法在别人不知道的情况下伪造它。而ECDSA签名和真实签名的区别在于，伪造ECDSA签名是根本不可能的。</p><h3 id="1-2-原理"><a href="#1-2-原理" class="headerlink" title="1.2 原理"></a>1.2 原理</h3><p>原理非常简单，有一个数学方程，在图上画了一条曲线，然后你在这条曲线上面随机选取了一个点作为你的 <code>原点(point of origin)</code>。接着你产生了一个随机数，作为你的 <code>私钥(Private key)</code>，最后你用上面的随机数和原点通过一些复杂的魔法数学方程得到该条曲线上面的第二个点，这是你的 <code>公钥(Public key)</code>。</p><p>当你想要对一个文件进行签名的时候，你会用这个私钥（随机数）和文件的哈希（一串独一无二的代表该文件的数）组成一个魔法数学方程，这就是你的签名。签名本身将被分成两部分，称为 <code>R</code> 和 <code>S</code> 。为了验证签名的正确性，你只需要公钥（用私钥在曲线上面产生的点）并将公钥和签名的一部分 <code>S</code> 一起代入另外一个方程，如果这个签名是由私钥正确签名过的数字签名，那么它将给出签名的另外一部分 <code>R</code>。简单来说，一个数字签名包含两个数字：<code>R</code>和<code>S</code>。你使用一个私钥来产生<code>R</code>和<code>S</code>，如果将公钥和 <code>S</code> 代入被选定的魔法数学方程给出 <code>R</code> 的话，这个签名就是有效的。仅仅知道公钥是无法知道私钥或者创建出数字签名。</p><h3 id="1-3-为什么使用ECDSA"><a href="#1-3-为什么使用ECDSA" class="headerlink" title="1.3 为什么使用ECDSA"></a>1.3 为什么使用ECDSA</h3><p>对于 <code>ECDSA</code> 算法，需要知道以下参数：</p><ul><li><code>a b</code>：椭圆曲线方程 $y^2&#x3D;x^3+a\cdot x+b$ 的参数</li><li><code>p</code>：模运算的底</li><li><code>N</code>：椭圆曲线上点的个数</li><li><code>G</code>：选中的参考的起点，可以是曲线上的任意一点</li></ul><p>总结一下：首先，你有一对密钥：公钥和私钥，私钥是一个随机数，也是160比特大小，公钥是将曲线上的点 $G$ 与私钥相乘以后的曲线上的点。令 $dA$ 表示私钥，一个随机数，$Qa$ 表示公钥，曲线上面的一个点，我们有 $Qa&#x3D;dA\cdot G$，其中 $G$ 是曲线上面的参考点。</p><h3 id="1-4-哈希函数–SHA1"><a href="#1-4-哈希函数–SHA1" class="headerlink" title="1.4 哈希函数–SHA1"></a>1.4 哈希函数–SHA1</h3><h3 id="1-5-签名"><a href="#1-5-签名" class="headerlink" title="1.5 签名"></a>1.5 签名</h3><p>签名本身是40字节，由各20字节的值来进行表示。第一个值为 $R$，第二个为 $S$。值对 $(R,S)$ 就是 <code>ECDSA</code> 签名。</p><p>如何创建这一值对：</p><ul><li>生成一个20字节的随机数 $k$</li><li>利用点乘法计算 $P &#x3D; k\cdot G$，其中 $P$ 的<strong>横坐标</strong>就是 $R$</li><li>利用SHA1计算信息 $m$ 的哈希，得到一个20字节的巨大的整数 $z$</li><li>计算 $S&#x3D;k^{-1}(z+dA\cdot R)mod\ p$</li></ul><p>其中 $k$ 是用来生成 $R$ 的随机数，$k^{-1}$ 是 $k$ 的模的乘法逆元。</p><h3 id="1-6-验证签名"><a href="#1-6-验证签名" class="headerlink" title="1.6 验证签名"></a>1.6 验证签名</h3><p>只需要计算<br>$$<br>P’&#x3D;S^{-1}\cdot z\cdot G+S^{-1}\cdot R\cdot Qa<br>$$<br>如果 $P’$ 的横坐标等于 $R$，就说明签名是有效的。</p><p><strong>推导过程：</strong><br>$$<br>P’&#x3D;S^{-1}\cdot z\cdot G+S^{-1}\cdot R\cdot Qa&#x3D;S^{-1}\cdot z\cdot G+S^{-1}\cdot R\cdot dA\cdot G&#x3D;S^{-1}\cdot G(z+R\cdot dA)&#x3D;k\cdot G&#x3D;P<br>$$</p><h2 id="2-素数群数字签名（DSA）"><a href="#2-素数群数字签名（DSA）" class="headerlink" title="2 素数群数字签名（DSA）"></a>2 素数群数字签名（DSA）</h2><p>素数群 $G$ 的阶为 $q$，生成元为 $g$，哈希函数 $H:{0,1}^*\to \mathbb{Z}_q $，哈希函数 $H^{‘}:G\to\mathbb{Z}_q$</p><p><strong>密钥生成：</strong></p><p>私钥为随机数 $x\in\mathbb{Z}_q$，公钥为 $y$，其中 $y&#x3D;g^x$</p><p><strong>签名：</strong></p><p>对于消息 $m\in\mathbb{Z}_q$，选择随机数 $k\in\mathbb{Z}_q$，计算 $R&#x3D;g^{k^{-1}}$，计算 $r&#x3D;H^{‘}(R)$，计算 $s&#x3D;k(m+xr)mod\ q$，则最终的签名为 $(r,s)$</p><p><strong>验证：</strong></p><p>校验 $(r,s)$ 的取值范围 $\mathbb{Z}_q$，计算 $R^{‘}&#x3D;g^{ms^{-1}mod\ q}y^{rs^{-1}mod\ q}$，校验 $r\overset{?}{&#x3D;} H’(R’)$</p><p><strong>公式推导：</strong><br>$$<br>R’&#x3D;g^{ms^{-1}mod\ q}y^{rs^{-1}mod\ q}&#x3D;g^{ms^{-1}mod\ q}g^{xrs^{-1}mod\ q}&#x3D;g^{s^{-1}(m+xr)mod\ q}&#x3D;g^{k^{-1}}&#x3D;R<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
          <category> 密码学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字签名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2023/03/27/Git/"/>
      <url>/2023/03/27/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1-版本控制"><a href="#1-版本控制" class="headerlink" title="1 版本控制"></a>1 版本控制</h2><p>版本控制是一种记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的系统</p><h3 id="1-1-集中式版本控制"><a href="#1-1-集中式版本控制" class="headerlink" title="1.1 集中式版本控制"></a>1.1 集中式版本控制</h3><p>集中化的版本控制系统诸如 CVS，SVN 以及 Perforce 等，都有一个单一的集 中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</p><h3 id="1-2-分布式版本控制"><a href="#1-2-分布式版本控制" class="headerlink" title="1.2 分布式版本控制"></a>1.2 分布式版本控制</h3><h2 id="2-初始化配置"><a href="#2-初始化配置" class="headerlink" title="2 初始化配置"></a>2 初始化配置</h2><p><strong>命令：</strong></p><ul><li><code>git config --global user.name &quot;zhliu9802&quot;</code> ：配置用户信息中的用户名为 <code>zhliu9802</code></li><li><code>git config --list</code>：查看所有范围的配置信息</li><li><code>git config --list --local</code>：只看对当前仓库有效的配置信息，<code>--local</code> 可以更改为 <code>--global</code> 、<code>--system</code></li><li><code> git config --global --unset user.name</code>：删除配置信息中的用户名信息</li></ul><blockquote><ol><li><code>--global</code>：对当前用户所有的仓库都有效，读写的是<code>~/.gitconfig</code> 文件</li><li><code>--local</code>：只对当前仓库有效，也是默认的，必须在一个 <code>git</code> 仓库中才能使用，读写的是 <code>./git/config</code> 文件</li><li><code>--system</code>：对系统所有登录的用户有效，基本不用，读写的是 <code>/etc/gitconfig</code></li></ol><p>注意：<code>local</code> 的优先级最高，其次是 <code>global</code>，最后是 <code>system</code></p></blockquote><p><strong>案例1：</strong>配置用户信息，如用户名和邮箱</p><pre><code class="bash">$ git config --global user.name &quot;zhliu9802&quot;$ git config --global user.email &quot;zhliu9802@163.com&quot;</code></pre><p><strong>案例2：</strong>查看当前配置信息</p><pre><code class="bash"># 查看已有的配置信息$ git config --list --global# 输出diff.astextplain.textconv=astextplainfilter.lfs.clean=git-lfs clean -- %ffilter.lfs.smudge=git-lfs smudge -- %ffilter.lfs.process=git-lfs filter-processfilter.lfs.required=truehttp.sslbackend=opensslhttp.sslcainfo=F:/Software/Git/mingw64/etc/ssl/certs/ca-bundle.crtcore.autocrlf=truecore.fscache=truecore.symlinks=falsepull.rebase=falsecredential.helper=managercredential.https://dev.azure.com.usehttppath=trueinit.defaultbranch=masteruser.name=zhliu9802user.email=zhliu9802@163.com</code></pre><p><strong>案例3：</strong>删除案例2中设置的用户名，并查看删除后的配置信息</p><pre><code class="bash"># 删除配置信息$ git config --global --unset user.name$ git config --list --global# 输出diff.astextplain.textconv=astextplainfilter.lfs.clean=git-lfs clean -- %ffilter.lfs.smudge=git-lfs smudge -- %ffilter.lfs.process=git-lfs filter-processfilter.lfs.required=truehttp.sslbackend=opensslhttp.sslcainfo=F:/Software/Git/mingw64/etc/ssl/certs/ca-bundle.crtcore.autocrlf=truecore.fscache=truecore.symlinks=falsepull.rebase=falsecredential.helper=managercredential.https://dev.azure.com.usehttppath=trueinit.defaultbranch=masteruser.email=zhliu9802@163.com</code></pre><h2 id="3-Git底层概念（底层命令）"><a href="#3-Git底层概念（底层命令）" class="headerlink" title="3 Git底层概念（底层命令）"></a>3 Git底层概念（底层命令）</h2><h3 id="3-1-git目录"><a href="#3-1-git目录" class="headerlink" title="3.1 .git目录"></a>3.1 .git目录</h3><ul><li><code>HEAD</code>：存放<code>HEAD</code>指针当前指向的引用，即告诉我们当前工作在哪个分支</li><li><code>config</code>：存放本地仓库的配置信息，只有指定配置信息为<code>--local</code>时才会发生改变</li><li><code>refs</code>：包含 <code>heads</code> 和 <code>tags</code> ，<code>heads</code> 存放分支文件，里边有具体的分支文件，其中每个分支保存了一个哈希值</li><li><code>objects</code>：git数据库</li><li><code>index</code>：git暂存区</li></ul><h3 id="3-2-区域和对象"><a href="#3-2-区域和对象" class="headerlink" title="3.2 区域和对象"></a>3.2 区域和对象</h3><h4 id="3-2-1-区域"><a href="#3-2-1-区域" class="headerlink" title="3.2.1 区域"></a>3.2.1 区域</h4><ul><li><strong>工作区</strong>：沙箱环境</li><li><strong>暂存区</strong></li><li><strong>版本库</strong></li></ul><h4 id="3-2-2-对象"><a href="#3-2-2-对象" class="headerlink" title="3.2.2 对象"></a>3.2.2 对象</h4><h5 id="3-2-2-1-git对象"><a href="#3-2-2-1-git对象" class="headerlink" title="3.2.2.1 git对象"></a>3.2.2.1 git对象</h5><p>git对象是 <code>key:value</code> 组成的键值对，<code>key</code> 是 <code>value</code> 对应的哈希值，键值对在git内部是一个 <code>blob</code> 类型。git对象只能存储内容，并不能代表项目的一个版本</p><p><strong>git对象创建时机：</strong></p><ul><li>当将文件或者从控制台输入的内容被git所管理时，git就会在内部创建git对象</li><li>当文件内容被修改（也可以被看作是更新了一个版本），重新写入版本库时，也会生成新的git对象</li></ul><p><strong>操作：</strong></p><pre><code class="bash">$ git init # 直接从控制台写入git对象# -w：写入数据对象到git数据库，若不指定该选项，则只会输出内容所对应的hash值# --stdin：从标准输入流中读取内容$ echo &quot;test content&quot; | git hash-object -w --stdin# 查看git数据库中的对象$ find .git/objects -type -f</code></pre><p>结果为 <code>.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code>，其中 <code>d670460b4b4aece5915caf5c68d12f560a9fe3e4</code>，其中 <code>d670460b4b4aece5915caf5c68d12f560a9fe3e4</code> 就是内容 <code>test content</code> 所对应的 <code>SHA-1</code> 哈希值。上面说到，git对象是键值对，其中这个哈希值就是 <code> key</code>，所对应的 <code>value</code> 为</p><pre><code class="bash">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4 # 输出 test content</code></pre><p>此外，我们也可以查看该文件的类型：</p><pre><code class="bash">$ git cat-file -t d670460b4b4aece5915caf5c68d12f560a9fe3e # 输出 blob</code></pre><p>接下来，我们对一个文件进行简单的版本控制</p><pre><code class="bash">$ echo &quot;version 1&quot; &gt; test.txt$ git hash-object -w test.txt$ find .git/objects -type f# 输出结果.git/objects/83/baae61804e65cc73a7201a7252750c76066a30.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre><p>其中，<code>d670460b4b4aece5915caf5c68d12f560a9fe3e</code> 是我们通过标准输入流所创建的git对象，而 <code>83baae61804e65cc73a7201a7252750c76066a30</code> 是我们刚刚创建的git对象，接下来我们查看该对象的类型和内容：</p><pre><code class="bash">$ git cat-file -t 83baae61804e65cc73a7201a7252750c76066a30 # blob$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 # version 1</code></pre><p>然后，我们对 <code>test.txt</code> 进行修改，并创建git对象</p><pre><code class="bash"># 首先，我们没对test.txt进行修改，直接尝试创建git对象$ git hash-object -w test.txt$ find .git/objects -type f# 结果，跟上边进行对比，发现hash值并未改变，即并未创建git对象.git/objects/83/baae61804e65cc73a7201a7252750c76066a30.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4# 对test.txt内容进行修改，添加 version 2，然后尝试创建git对象$ git hash-object -w test.txt$ find .git/objects -type f# 结果，发现多了一个hash值：0c1e7391ca4e59584f8b773ecdbbb9467eba1547.git/objects/0c/1e7391ca4e59584f8b773ecdbbb9467eba1547.git/objects/83/baae61804e65cc73a7201a7252750c76066a30.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre><p>经过上边的实验，我们发现，git对象创建与文件内容息息相关，因为文件内容不变，hash值也不会变。</p><p><strong>命令总结：</strong></p><ul><li>&#96;&#96;git hash-object &lt;文件路径&gt;&#96;：返回对应文件内容的键值，该键值是一个长度为40个字符的校验和，这是一个SHA-1哈希值</li><li><code>git hash-onject -w &lt;文件路径&gt;</code>：将文件保存，存储在 <code>.git/objects/</code> 下</li><li><code>git cat-file -p &lt;哈希值&gt;</code>：查看对应哈希（也是对应文件）的内容</li><li><code>git cat-file -t &lt;哈希值&gt;</code>：查看该哈希（或者该文件）存储的类型</li></ul><p><strong>问题：</strong></p><ul><li>记住文件每个版本的hash值并不现实</li><li>在git中并没有保存文件名，只是保存了文件内容</li></ul><h5 id="3-2-2-2-tree对象"><a href="#3-2-2-2-tree对象" class="headerlink" title="3.2.2.2 tree对象"></a>3.2.2.2 tree对象</h5><p>树对象能够解决文件名保存的问题，也允许我们将多个文件组织到一起。Git以一种类似于UNIX文件系统的方式存储内容。所有内容均以 树对象和数据对象(git 对象)的形式存储，其中树对象对应了 UNIX 中的目录项（文件+文件夹）， 数据对象(git 对象)则大致上对应文件内容。一个树对象包含了一条或多条记录（每条记录含有一个指向 git 对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息）。一个树对象也可以包含另一个树对象。</p><p><strong>操作：</strong></p><p>向 <code>test.txt</code> 文件中写入 <code>version 1</code>，并将该文件提交到暂存区</p><pre><code class="bash">$ echo &quot;version 1&quot; &gt; test.txt$ git hash-object -w test.txt# 返回hash值：83baae61804e65cc73a7201a7252750c76066a30# 查看暂存区中的内容$ git ls-files -s # 暂存区中目前什么也没有# 给git对象取文件名，并将该记录保存到暂存区（不会保存到git数据库中）$ git update-index --add --cacheinfo 100644 83baae61804e65cc73a7201a7252750c76066a30 test.txt# 将树对象写入到git数据库中$ git write-tree$ find .git/objects -type # 结果.git/objects/83/baae61804e65cc73a7201a7252750c76066a30.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579# 查看树对象的类型和内容$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579 # 100644 blob 83baae61804e65cc73a7201a7252750c76066a30    test.txt</code></pre><p>新增 <code>new.txt</code> ，将 <code>new.txt</code> 和 <code>test.txt</code> 文件的第二个版本（内容为<code>version 2</code>）塞入暂存区，并生成树对象</p><pre><code class="bash"># 编辑test.txt$ git hash-object -w test.txt # 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a$ git update-index --add --cacheinfo 100644 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt$ echo &quot;new file&quot; &gt; new.txt$ git hash-object -w new.txt # fa49b077972391ad58037050f2a75f74e3671e92# 下面这句话等价于 git update-index --add --cacheinfo 100644 fa49b077972391ad58037050f2a75f74e3671e92 new.txt$ git update-index --add new.txt$ git write-tree</code></pre><p>将第一个树对象加入到第二个树对象，使其称为新的树对象</p><pre><code class="bash"># 将第一个树对象加入到第二个树对象，并将第一个树对象改名为 bakgit read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579 git write-tree $ find .git/objects/ -type f# 结果：第一个为之前的第二个树对象.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614.git/objects/83/baae61804e65cc73a7201a7252750c76066a30.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92</code></pre><p>此时，最后的树对象为：</p><img src="/2023/03/27/Git/树对象.png" alt="最终树对象示意图" style="zoom:80%;"><p><strong>命令总结：</strong></p><ul><li><code>git update-index --add --cacheinfo &lt;文件模式&gt; &lt;哈希值&gt; &lt;文件名&gt;</code>：给git对象取文件名，并将该记录保存到暂存区（不会保存到git数据库中）<ul><li>文件模式：100644，普通文件；100755，可执行文件；120000，符号链接</li><li><code>--cacheinfo</code>：因为将要添加的文件位于 Git 数据库中，而不是位于当前目录下，所以需要 <code>--cacheinfo</code></li><li><code>--add</code>：因为此前该文件并不在暂存区中，首次需要<code>--add</code></li></ul></li><li><code>git write-tree</code>：将树对象保存到git数据库中</li><li><code>git update-index --add &lt;文件名&gt;</code>：第一条命令的简单模式，与第一条命令作用一致</li></ul><blockquote><p>注意：当将树对象保存到git数据库中后，暂存区中的内容并不会清空</p></blockquote><h5 id="3-2-2-3-commit对象"><a href="#3-2-2-3-commit对象" class="headerlink" title="3.2.2.3 commit对象"></a>3.2.2.3 commit对象</h5><p>我们可以通过调用 <code>commit-tree</code> 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话 第一次将暂存区做快照就没有父对象）</p><p>接上边树对象的例子，指定第一棵树来创建提交对象</p><pre><code class="bash"># first commit 是提交信息，返回提交对象的hash值：f068d1749b2e60ddb2434d1ce9f29a35f28c6928$ echo &quot;first commit&quot; | git commit-tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579  # 查看提交对象的类型以及内容$ git cat-file -t f068d1749b2e60ddb2434d1ce9f29a35f28c6928 # commit$ git cat-file -p f068d1749b2e60ddb2434d1ce9f29a35f28c6928</code></pre><p>提交对象的内容如下：</p><ul><li>一个顶层树对象，代表当前项目的快照</li><li>用户配置信息，如 <code>user.name</code> 和 <code>user.email</code>，并添加了时间戳</li><li>空行</li><li>提交注释</li></ul><pre><code class="text">tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579author zhliu9802 &lt;zhliu9802@163.com&gt; 1679791369 +0800committer zhliu9802 &lt;zhliu9802@163.com&gt; 1679791369 +0800first commit</code></pre><p>接着，我们创建第二棵树的提交对象</p><pre><code class="bash"># -p：指定父提交对象，即我们上边第一次创建的提交对象的hash值，返回：d3211ccc8180d037de7bfe36e92380ddac2f6a3d$ echo &quot;second commit&quot; | git commit-tree 3c4e9cd789d88d8d89c1073707c3585e41b0e614 -p f068d1749b2e60ddb2434d1ce9f29a35f28c6928# 查看这次提交对象的内容$ git cat-file -p d3211ccc8180d037de7bfe36e92380ddac2f6a3d</code></pre><p>内容如下：</p><pre><code class="text">tree 3c4e9cd789d88d8d89c1073707c3585e41b0e614parent f068d1749b2e60ddb2434d1ce9f29a35f28c6928author zhliu9802 &lt;zhliu9802@163.com&gt; 1679792432 +0800committer zhliu9802 &lt;zhliu9802@163.com&gt; 1679792432 +0800second commit</code></pre><p>命令总结：</p><ul><li><code>echo &lt;message&gt; | git commit-tree &lt;tree对象hash&gt; [-p &lt;父commit对象hash&gt;] </code></li></ul><h2 id="4-Git本地操作（高层命令）"><a href="#4-Git本地操作（高层命令）" class="headerlink" title="4 Git本地操作（高层命令）"></a>4 Git本地操作（高层命令）</h2><h3 id="4-1-工作流程"><a href="#4-1-工作流程" class="headerlink" title="4.1 工作流程"></a>4.1 工作流程</h3><ol><li>创建工作目录，并对工作目录进行修改</li><li><code>git add ./</code>，等价于执行以下两条指令</li></ol><pre><code class="bash"># 将git对象写入git数据库，并在暂存区创建树对象$ git hash-object -w &lt;文件名&gt; # 可能会执行多次，修改了多少个文件就执行多少次$ git update-index --add &lt;文件名&gt;</code></pre><ol start="3"><li><code>git commit -m &quot;注释内容&quot;</code>，等价于执行以下两条指令</li></ol><pre><code class="bash"># 将树对象存入git数据库，并创建commit对象$ git write-tree$ echo &quot;注释内容&quot; | git commit-tree &lt;tree对象hash&gt; [-p &lt;父commit对象hash&gt;]</code></pre><h3 id="4-2-初始化本地仓库"><a href="#4-2-初始化本地仓库" class="headerlink" title="4.2 初始化本地仓库"></a>4.2 初始化本地仓库</h3><p><strong>命令：</strong></p><ul><li><code>git init</code>：初始化仓库，在当前文件夹下会生成一个 <code>.git</code> 目录，并对当前目录开始使用 <code>git</code> 管理</li></ul><p><strong>案例：</strong>在桌面创建 <code>workspace</code> 目录，并对该目录开始使用 <code>git</code> 管理</p><pre><code class="bash">$ mkdir workspace &amp;&amp; cd workspace$ git init</code></pre><h3 id="4-3-新增操作（C）"><a href="#4-3-新增操作（C）" class="headerlink" title="4.3 新增操作（C）"></a>4.3 新增操作（C）</h3><h4 id="4-3-1-暂存文件"><a href="#4-3-1-暂存文件" class="headerlink" title="4.3.1 暂存文件"></a>4.3.1 暂存文件</h4><p><strong>命令：</strong></p><ul><li><code>git add &lt;文件或目录&gt;</code>：将该文件或目录添加到暂存区  ，同时这些文件将被标记为<strong>已暂存（staged）</strong>状态</li><li><code>git add -u</code>：将所有已经被git管理的文件一起提交到暂存区</li><li><code>git ls-files -s</code>：查看暂存区中的内容</li></ul><p><strong>案例：</strong></p><ul><li>在桌面创建 <code>workspace</code> 目录，并对其开始使用 <code>git</code> 管理</li><li>在该目录中创建 <code>a.txt</code> ，写入内容 <code>a.txt v1</code>，查看该文件目前的状态。</li><li>将该文件提交到暂存区，再次查看该文件的状态。</li><li>在 <code>a.txt</code> 中再添加一条注释，加完注释后再次查看该文件的状态</li><li>查看暂存区中文件的修改情况</li><li>查看暂存区中有哪些文件</li></ul><pre><code class="bash">$ mkdir workspace &amp;&amp; cd workspace$ git init$ echo &quot;a.txt v1&quot; &gt; a.txt$ git status$ git add a.txt$ git status$ vim a.txt$ git status$ git diff $ git diff --cached</code></pre><p>执行第一次 <code>git status</code> 时，会出现下图所示的信息，该信息表示 <code>a.txt</code> 还没有提交到暂存区，该文件当前的状态为<strong>已修改（红色）</strong>：</p><img src="/2023/03/27/Git/未暂存文件状态.png" alt="image-20230323222410194" style="zoom:80%;"><p>执行第二次 <code>git status</code> 时，会出现下图所示的信息，该信息表示 <code>a.txt</code> 已经提交到暂存区，但是还未提交到代码库中，该文件当前的状态为<strong>已暂存（绿色）</strong>：</p><img src="/2023/03/27/Git/已暂存未提交文件状态.png" alt="image-20230323222610351" style="zoom:80%;"><p>执行第三次 <code>git status</code> 时，会出现下图所示的信息，根据前两次可知，绿色表示该文件已暂存（<code>stage</code>），红色表示该文件已修改（<code>not staged</code>），一个文件居然同时有两种状态，如果此时我们执行 <code>git commmit</code> 命令，我们会将上次暂存的文件（即没有添加注释的文件）推送至代码库，而不是我们之后修改的文件。为了解决这种情况，我们需要将该文件重新添加到暂存区，即执行 <code>git add a.txt</code>，此时再次查看文件状态，只有已暂存状态（绿色）存在：</p><img src="/2023/03/27/Git/修改暂存文件的文件状态.png" alt="image-20230323223318293" style="zoom:80%;"><h4 id="4-3-2-提交文件"><a href="#4-3-2-提交文件" class="headerlink" title="4.3.2 提交文件"></a>4.3.2 提交文件</h4><p><strong>作用：</strong>将暂存区中的内容提交到版本库</p><p><strong>命令：</strong></p><ul><li><code>git commit </code>：启动文本编辑器以便输入本次提交的说明【当注释过多时，使用这个】</li><li><code>git commit -a -m</code>：跳过使用暂存区域，自动把所有已经跟踪过的文件暂存起来一并提交【必须之前提交过的文件才能使用 <code>-a</code> 参数】</li></ul><pre><code class="bash">$ git commit -m &quot;注释内容&quot;</code></pre><h3 id="4-4-修改操作（U）"><a href="#4-4-修改操作（U）" class="headerlink" title="4.4 修改操作（U）"></a>4.4 修改操作（U）</h3><h4 id="4-4-1-更改文件名"><a href="#4-4-1-更改文件名" class="headerlink" title="4.4.1 更改文件名"></a>4.4.1 更改文件名</h4><p><strong>方法1：</strong></p><pre><code class="bash">$ mv readme readme.md$ git add readme.md$ git rm readme$ git commit -m &quot;重命名readme为readme.md&quot;</code></pre><p><strong>方法2：</strong></p><pre><code class="bash">$ git mv readme readme.txt$ git commit -m &quot;重命名readme为readme.md&quot;</code></pre><h4 id="4-4-2-修改注释"><a href="#4-4-2-修改注释" class="headerlink" title="4.4.2 修改注释"></a>4.4.2 修改注释</h4><ul><li><p><code>git commit --amend</code>：针对最近一次的 <code>commit</code> 的 <code>message</code> 进行修改</p></li><li><p><code>git rebase -i &lt;父节点的hash值&gt;</code>：修改历史 <code>commit</code> 的 <code>message </code>注释</p></li></ul><h3 id="4-5查询操作（R）"><a href="#4-5查询操作（R）" class="headerlink" title="4.5查询操作（R）"></a>4.5查询操作（R）</h3><h4 id="4-5-1-查看文件状态"><a href="#4-5-1-查看文件状态" class="headerlink" title="4.5.1 查看文件状态"></a>4.5.1 查看文件状态</h4><p> <strong>命令：</strong></p><ul><li><code>git status</code>：查看当前目录中文件的状态</li><li><code>git ls-files -s</code>：查看暂存区中的文件</li></ul><p><strong>文件状态：</strong></p><p>在工作目录中的所有文件，只有两种状态：<strong>已跟踪</strong>、<strong>未跟踪</strong></p><ul><li>已跟踪：指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是<strong>已提交</strong>，<strong>已修改</strong>或者<strong>已暂存</strong></li><li>未跟踪：除了已跟踪的文件外，其他都是未跟踪</li></ul><h4 id="4-5-2-查看文件差异"><a href="#4-5-2-查看文件差异" class="headerlink" title="4.5.2 查看文件差异"></a>4.5.2 查看文件差异</h4><ul><li><code>git diff</code>：查看工作区和暂存区之间的文件差异</li><li><code>git diff --staged</code> 或 <code>git diff --cached</code>：查看某个文件当前在暂存区和上次版本库之间的差异【查看哪些修改被暂存了，但是还没被提交】</li><li><code>git diff -- &lt;文件名&gt;</code>：只查看某个文件工作区和暂存区的差别</li><li><code>git diff &lt;分支1/hash&gt; &lt;分支2/hash&gt;</code>：查看两个分支之间的差异</li><li><code>git diff &lt;分支1/hash&gt; &lt;分支2/hash&gt; -- &lt;文件路径&gt;</code>：查看两个分支指定文件之间的差异</li></ul><h4 id="4-5-3-查看版本演进历史"><a href="#4-5-3-查看版本演进历史" class="headerlink" title="4.5.3 查看版本演进历史"></a>4.5.3 查看版本演进历史</h4><ul><li><code>git log --oneline</code> ：只查看<strong>当前分支</strong>的演进历史</li><li><code>git log --oneline &lt;分支名&gt;</code>：只查看指定分支的演进历史</li><li><code>git log --oneline --decorate --graph --all</code>：查看整个项目的分支图</li><li><code>git log -n4 --oneline</code>：查看当前分支前四行的演进历史</li><li><code>git log --all</code>：查看所有分支的演进历史</li><li><code>git help --web log</code>：以网页的形式查看 <code>git log</code> 的帮助手册</li><li><code>git reflog</code>：查看所有的历史记录，只要 <code>HEAD</code> 移动了就会被记录</li><li><code>git log -g</code></li></ul><h3 id="4-9-删除操作（D）"><a href="#4-9-删除操作（D）" class="headerlink" title="4.9 删除操作（D）"></a>4.9 删除操作（D）</h3><p><strong>方式1：</strong>从工作目录手动删除文件</p><pre><code class="bash"># 首先手动从工作目录删除该文件$ git add ./$ git commit -m &quot;del new.txt&quot;</code></pre><p><strong>方式2：</strong></p><pre><code class="bash">$ git rm new.txt$ git commit -m &quot;del new.txt&quot;</code></pre><h2 id="5-git分支操作"><a href="#5-git分支操作" class="headerlink" title="5 git分支操作"></a>5 git分支操作</h2><p>分支就是指向提交对象的指针</p><h3 id="5-1-查看分支"><a href="#5-1-查看分支" class="headerlink" title="5.1 查看分支"></a>5.1 查看分支</h3><ul><li><code>git branch</code>：显示所有分支的列表</li><li><code>git branch -v</code>：查看每一个分支的最后一次提交</li></ul><h3 id="5-2-创建分支"><a href="#5-2-创建分支" class="headerlink" title="5.2 创建分支"></a>5.2 创建分支</h3><ul><li><code>git branch &lt;分支名&gt;</code>：新建分支，并指向当前分支所指向的 <code>commit</code> 对象（master分支）</li><li><code>git branch &lt;分支名&gt; &lt;commitHash&gt;</code>：新建一个分支，并使该分支指向指定的commit对象</li><li><code>git branch -b &lt;分支名&gt;</code>：创建并切换分支，即让 <code>HEAD</code> 指向该分支</li></ul><h3 id="5-3-切换分支"><a href="#5-3-切换分支" class="headerlink" title="5.3 切换分支"></a>5.3 切换分支</h3><p>切换分支就是使 <code>HEAD</code> 指向另外一个分支</p><ul><li><code>git checkout &lt;分支名&gt;</code></li></ul><p>切换分支会改变三个东西：</p><ul><li>HEAD</li><li>暂存区  <code>git ls-files -s</code></li><li>工作目录</li></ul><blockquote><p>注意：切换分支之前，务必保证当前分支是<strong>已提交</strong>状态，使用 <code>git status</code> 查看文件当前状态，否则会污染master分支。</p></blockquote><p>坑点：</p><ul><li><p>在切换分支时，如果当前分支有<strong>新文件未暂存</strong>或<strong>未提交</strong>，可以切换分支，但是 <code>git</code> 会默认带到所切换的分支上。</p></li><li><p>在切换分支时，如果当前分支修改了已经提交的内容且修改后没有进行提交，则不允许切换分支。</p></li></ul><h3 id="5-4-删除分支"><a href="#5-4-删除分支" class="headerlink" title="5.4 删除分支"></a>5.4 删除分支</h3><ul><li><code>git branch -D &lt;分支名/hash值&gt;</code>：强制删除分支，如果分支上的内容没有被合并，就需要强制删除</li><li><code>git branch -d &lt;分支名/hash值&gt;</code>：删除分支，只有合并后的分支（空分支）才可以这样删除</li></ul><blockquote><p>注意：不能删除当前所在分支，必须切到 <code>master</code> 分支后，再删除</p></blockquote><h3 id="5-5-合并分支"><a href="#5-5-合并分支" class="headerlink" title="5.5 合并分支"></a>5.5 合并分支</h3><h4 id="5-5-1-快进合并"><a href="#5-5-1-快进合并" class="headerlink" title="5.5.1 快进合并"></a>5.5.1 快进合并</h4><pre><code class="bash">$ git chechout master$ git merge &lt;分支名/commitHash&gt;  # 快进 fast-forwarding合并</code></pre><h4 id="5-5-2-典型合并"><a href="#5-5-2-典型合并" class="headerlink" title="5.5.2 典型合并"></a>5.5.2 典型合并</h4><pre><code class="bash">$ git checkout master$ git merge &lt;分支名/commitHash&gt; # 此时命令行会出现合并冲突，比如a.txt合并冲突$ vim a.txt # 修改a.txt的内容，分析哪些代码留，哪些代码删，以解决冲突$ git add ./$ git commit -m &quot;消息&quot;</code></pre><h2 id="6-git存储"><a href="#6-git存储" class="headerlink" title="6 git存储"></a>6 git存储</h2><p>当我们在开发中被临时指派了任务，而且目前的任务还未完成，我们该怎么做？</p><h3 id="6-1-存储"><a href="#6-1-存储" class="headerlink" title="6.1 存储"></a>6.1 存储</h3><p>将当前任务添加到 <code>stash</code> 列表【栈】上</p><pre><code class="bash">$ git stash</code></pre><h3 id="6-2-查看存储"><a href="#6-2-查看存储" class="headerlink" title="6.2 查看存储"></a>6.2 查看存储</h3><p>查看 <code>stash</code> 列表</p><pre><code class="bash">$ git stash list </code></pre><h3 id="6-3-恢复存储"><a href="#6-3-恢复存储" class="headerlink" title="6.3 恢复存储"></a>6.3 恢复存储</h3><pre><code class="bash">$ git stash apply # 恢复上一次任务，但不会从stash列表中删除$ git stash apply &lt;commitHash&gt; # 恢复指定任务$ git stash pop # 恢复上次任务，并将该任务从 stash 列表中删除</code></pre><h3 id="6-4-删除存储"><a href="#6-4-删除存储" class="headerlink" title="6.4 删除存储"></a>6.4 删除存储</h3><pre><code class="bash">$ git stash list # 查看存储列表$ git stash drop stash@&#123;0&#125; # 删除指定序号为stash@&#123;0&#125;的存储项</code></pre><h2 id="7-git撤销"><a href="#7-git撤销" class="headerlink" title="7 git撤销"></a>7 git撤销</h2><p>撤销修改就是查看输入 <code>git status</code> 后的提示信息</p><h3 id="7-1-撤销工作区修改"><a href="#7-1-撤销工作区修改" class="headerlink" title="7.1 撤销工作区修改"></a>7.1 撤销工作区修改</h3><p>注意：撤销操作仅对已经提交的文件有效</p><p>下面的撤销命令可能会更新，注意使用 <code>git status</code> 查看系统提示的最新命令</p><ul><li><code>git restore &lt;文件名&gt;</code>：撤销修改</li></ul><h3 id="7-2-撤销暂存区的暂存"><a href="#7-2-撤销暂存区的暂存" class="headerlink" title="7.2 撤销暂存区的暂存"></a>7.2 撤销暂存区的暂存</h3><ul><li><p><code>git restore --staged &lt;file&gt;</code>：将暂存区中指定文件恢复成和HEAD一致</p></li><li><p><code>git reset --mixed HEAD &lt;filename&gt;</code>：将暂存区中指定文件恢复成和HEAD一致，可以简写成 <code>git reset HEAD &lt;filename&gt;</code> 或 <code>git reset &lt;filename&gt;</code></p></li></ul><h3 id="7-3-撤销版本库的提交"><a href="#7-3-撤销版本库的提交" class="headerlink" title="7.3 撤销版本库的提交"></a>7.3 撤销版本库的提交</h3><ol><li>内容写错了，需要重新提交</li></ol><pre><code class="bash"># 重新编辑写错的文档$ git add  ./$ git commit -m &quot;xxxxx&quot;</code></pre><ol start="2"><li>注释写错了，只能修改最近一次提交的注释</li></ol><pre><code class="bash">$ git commit --amend</code></pre><h2 id="8-git重置"><a href="#8-git重置" class="headerlink" title="8 git重置"></a>8 git重置</h2><p>假设当前的分支图如下所示：</p><img src="/2023/03/27/Git/git重置初始状态分支图.png" alt="git重置初始状态分支图" style="zoom:80%;"><h3 id="8-1-软重置"><a href="#8-1-软重置" class="headerlink" title="8.1 软重置"></a>8.1 软重置</h3><p>经过软重置之后，<code>HEAD</code> 以及所指向的分支都会进行改变，这就导致版本库的变化。</p><p>软重置本质上撤销了上一次的 <code>commit</code> 操作。</p><pre><code class="bash">$ git reset --soft HEAD~$ git reset --soft HEAD~2</code></pre><p>当执行完 <code>git reset --soft HEAD~</code> 之后，分支图如下所示：</p><img src="/2023/03/27/Git/软重置后分支图.png" alt="软重置后分支图" style="zoom:80%;"><h3 id="8-2-mix重置"><a href="#8-2-mix重置" class="headerlink" title="8.2 mix重置"></a>8.2 mix重置</h3><p>会撤销上一次的 <code>commit</code>，而且还会取消暂存的东西</p><ul><li>不带文件名：撤销暂存区的所有</li></ul><pre><code class="bash">$ git reset --mixed HEAD~$ git reset HEAD~</code></pre><ul><li>带文件名：撤销暂存区指定文件，本质上就是将 <code>HEAD</code> 中的内容复制到 <code>Index</code> 中</li></ul><pre><code class="bash">$ git reset &lt;filename&gt;</code></pre><img src="/2023/03/27/Git/mix重置（不带路径）后分支图.png" alt="mix重置（不带路径）后分支图" style="zoom:80%;"><blockquote><p>注意：只有 <code>--mixed</code> 选项后才能加 <code>&lt;filename&gt;</code>，指定某一个文件回退</p></blockquote><h3 id="8-3-硬重置【危险操作】"><a href="#8-3-硬重置【危险操作】" class="headerlink" title="8.3 硬重置【危险操作】"></a>8.3 硬重置【危险操作】</h3><p>硬重置会重置工作目录中的内容，导致无法恢复！</p><img src="/2023/03/27/Git/硬重置后分支图.png" alt="硬重置后分支图" style="zoom:80%;"><h2 id="9-数据恢复"><a href="#9-数据恢复" class="headerlink" title="9 数据恢复"></a>9 数据恢复</h2><pre><code class="bash"># 首先使用下面命令，查看想要恢复到哪个提交对象时$ git reflog# 然后在这个提交对象上创建分支$ git branch &lt;分支名&gt; &lt;commitHash&gt;</code></pre><h2 id="10-tag"><a href="#10-tag" class="headerlink" title="10 tag"></a>10 tag</h2><p>Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。</p><h3 id="10-1-列出标签"><a href="#10-1-列出标签" class="headerlink" title="10.1 列出标签"></a>10.1 列出标签</h3><pre><code class="bash">$ git tag$ git tag -l &#39;1.8.5*&#39;</code></pre><h3 id="10-2-创建标签"><a href="#10-2-创建标签" class="headerlink" title="10.2 创建标签"></a>10.2 创建标签</h3><ul><li>轻量标签：很像一个不会改变的分支 - 它只是一个特定提交的引用</li></ul><pre><code class="bash">$ git tag &lt;tagname&gt;$ git tag &lt;tagname&gt; &lt;commitHash&gt;</code></pre><ul><li>附注标签：存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子 邮件地址、日期时间；还有一个标签信息。</li></ul><pre><code class="bash">$ git tag -a v1.4$ git tag -a v1.4 commitHash$ git tag -a v1.4 commitHash -m &#39;my version 1.4&#39;</code></pre><h3 id="10-3-查看特定标签"><a href="#10-3-查看特定标签" class="headerlink" title="10.3 查看特定标签"></a>10.3 查看特定标签</h3><pre><code class="bash">$ git show &lt;tagname&gt;</code></pre><h3 id="10-4-远程标签"><a href="#10-4-远程标签" class="headerlink" title="10.4 远程标签"></a>10.4 远程标签</h3><h3 id="10-5-删除标签"><a href="#10-5-删除标签" class="headerlink" title="10.5 删除标签"></a>10.5 删除标签</h3><pre><code class="bash">$ git tag -d &lt;tagname&gt;</code></pre><h3 id="10-6-检出标签"><a href="#10-6-检出标签" class="headerlink" title="10.6 检出标签"></a>10.6 检出标签</h3><p>如果你想查看某个标签所指向的文件版本，可以使用 <code>git checkout</code> 命令。虽然说这会使你的仓库处于“分离头指针（detacthed HEAD）”状态。在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非访问确切的提交哈希。因此， 如果你需要进行更改——比如说你正在修复旧版本的错误——这通常需要创建一个新分支：</p><pre><code class="bash">$ git checkout -b &lt;tagname&gt;</code></pre><p>会出现<strong>分离头指针</strong>的情况，解决方法是：<strong>创建新的分支，让HEAD指向该分支</strong></p><h2 id="11-备份"><a href="#11-备份" class="headerlink" title="11 备份"></a>11 备份</h2><h2 id="11-团队协作Github"><a href="#11-团队协作Github" class="headerlink" title="11 团队协作Github"></a>11 团队协作Github</h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
