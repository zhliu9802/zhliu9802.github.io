<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>拉普拉斯机制</title>
      <link href="/2023/04/05/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/04/05/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-Laplace分布"><a href="#0x00-Laplace分布" class="headerlink" title="0x00 Laplace分布"></a>0x00 Laplace分布</h1><p>Laplace分布是统计学的概念，是一种连续的概率分布。如果随机变量的概率密度函数分布为：<br>$$<br>Lap(x|\mu,b)&#x3D;\frac{1}{2b}e^{-\frac{|x-\mu|}{b}}<br>$$<br>那么它就是拉普拉斯分布。其中，$\mu$ 是位置参数，即该分布关于 $x&#x3D;\mu$ 对称；$b&gt;0$ 是尺度参数。拉普拉斯分布的期望是 $\mu$， 方差是 $2b^2$，偏度为0，峰度为3。</p><p>记位置参数为 $0$，尺度参数为 $b$ 的Laplace分布为 $Lap(b)$，那么其概率密度函数为<br>$$<br>Lap(x|b)&#x3D;\frac{e^{\frac{-|x|}{b}}}{2b}<br>$$</p><h1 id="0x01-Laplace机制"><a href="#0x01-Laplace机制" class="headerlink" title="0x01 Laplace机制"></a>0x01 Laplace机制</h1><p>拉普拉斯机制主要是针对<strong>数值型</strong>的查询，即 $f:\mathbb{N}^{|\mathcal{X}|}\rightarrow \mathbb{R}^k$，映射数据库为 $k$ 个实数</p><p><strong>$l1$敏感度</strong></p><blockquote><p>一个函数 $f:\mathbb{N}^{|\mathcal{X}|}\rightarrow \mathbb{R}^k$ 的 $l_1$ 的敏感度为：<br>$$<br>\Delta f&#x3D;\underset{x,y\in\mathbb{N}^{|\mathcal{X}|},||x-y||_1&#x3D;1}{max}||f(x)-f(y)||_1<br>$$</p></blockquote><p>$\Delta f$ 含义是：数据库中单条记录的改变对于函数 $f$ 的输出的最大改变是多少。</p><p><strong>Laplace机制</strong></p><blockquote><p>给任意函数 $f:\mathbb{N}^{|\mathcal{X}|}\rightarrow \mathbb{R}^k$，下面定义的机制 $M$ 满足 $\epsilon-$差分隐私：<br>$$<br>M_L(x,f(·),\epsilon) &#x3D; f(x)+Lap(\frac{s}{\epsilon})&#x3D;f(x)+(Y_1,Y_2,…,Y_k)<br>$$<br>其中，$s$ 是 $f$ 的敏感度；$Lap(S)$ 表示以均值为 $0$，缩放系数为 $S$ 的拉普拉斯分布采样。</p></blockquote><p>拉普拉斯机制简单来说就是在 $f$ 输出的 $k$ 个实数上加上噪声，噪声具体加多少由 $\Delta f$ 决定。如果 $\Delta f$ 比较大，那么相应的噪声的幅度就应该大一些。</p><p>接下来，证明 Laplace 满足差分隐私：</p><p>假设 $p_x$ 表示 $M_L(x,f,\epsilon )$ 的 <code>pdf</code>（probability density function），$p_y$ 表示 $M_L(y,f,c)$的 <code>pdf</code>，则对于某个输出 $z$，我们有：<br>$$<br>\frac{p_x(z)}{p_y(z)}&#x3D;\prod^{k}_{i&#x3D;1}\frac{e^{-\frac{\epsilon |f(y)_i-z_i|}{\Delta f}}}{e^{-\frac{\epsilon |f(x)<em>i-z_i|}{\Delta f}}}&#x3D;\prod^{k}</em>{i&#x3D;1}e^{\frac{\epsilon(|f(y)_i-z_i|-|f(x)<em>i-z_i|)}{\Delta f}}\leq\prod^{k}</em>{i&#x3D;1}e^{\frac{\epsilon(|f(x)_i-f(y)_i|)}{\Delta f}}&#x3D;e^{\frac{\epsilon\cdot ||f(x)-f(y)||_1}{\Delta f}}\leq e^{\epsilon}<br>$$</p><ul><li>第一个等号表示输出 $z$ 的概率，因为 $k$ 个输出之间是相互独立，且都满足拉普拉斯分布，可以将分布概率展开</li><li>第二个等号就是简单的化简</li><li>第三个不等号利用的是 <code>绝对值三角不等式</code>： $|a|-|b|\leq|a\pm b|\leq |a|+|b|$</li><li>第四个等号利用的是 <code>L1范数</code> 的定义</li><li>第五个不等号利用的是<strong>全局敏感度的定义</strong></li></ul><h1 id="0x02-应用实例"><a href="#0x02-应用实例" class="headerlink" title="0x02 应用实例"></a>0x02 应用实例</h1><h2 id="2-1-计数查询"><a href="#2-1-计数查询" class="headerlink" title="2.1 计数查询"></a>2.1 计数查询</h2><p>计数查询一般有形式：在数据库中有多少个记录满足性质 $P$ ？</p><p>由于计数查询的敏感度 $\Delta f&#x3D;1$（增加或者删除一个记录会使得计数至多改变1），所以根据拉普拉斯的机制，在计数查询上加上$Lap(\frac{1}{\epsilon}$) 采样的噪声是满足 $(\epsilon, 0)-$差分隐私的。</p><h2 id="2-2-直方图查询"><a href="#2-2-直方图查询" class="headerlink" title="2.2 直方图查询"></a>2.2 直方图查询</h2><p>假如我们有一个数据库，包含学生姓名、考试等级以及其他信息，我们想统计多少个学生考试等级为 $A$，多少个学生考试等级为 $B$，以此类推。这就是一个直方图查询的例子。</p><p>一般形式，查询把数据的全集 $\mathbb{N}^{|\mathcal{X}|}$ 划分成不相交的cell，然后查询每个cell里有多少个元素。由于每个cell不相交，增加或删除一个记录只影响一个cell，直方图查询的敏感度也是 $1$ ，所以在每个查询结果的每个cell加上在 $Lap(\frac{1}{\epsilon})$ 采样的噪声是满足 $(\epsilon, 0)-$差分隐私的。</p><h1 id="0x04-参考文献"><a href="#0x04-参考文献" class="headerlink" title="0x04 参考文献"></a>0x04 参考文献</h1><ol><li>Cynthia Dwork, Frank McSherry, Kobbi Nissim, and Adam Smith. Calibrating noise to sensitivity in private data analysis. In <em>Proceedings of the Third Conference on Theory of Cryptography</em>, TCC’06, 265–284. Berlin, Heidelberg, 2006. Springer-Verlag. URL: <a href="https://doi.org/10.1007/11681878_14">https://doi.org/10.1007/11681878_14</a>, <a href="https://doi.org/10.1007/11681878_14">doi:10.1007&#x2F;11681878_14</a>.</li><li><a href="https://zhuanlan.zhihu.com/p/405541748">差分隐私（三）——拉普拉斯机制详细介绍 - 知乎 (zhihu.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 隐私计算 </category>
          
          <category> 差分隐私 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐私计算 </tag>
            
            <tag> 差分隐私 </tag>
            
            <tag> 拉普拉斯机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指数机制</title>
      <link href="/2023/04/05/%E6%8C%87%E6%95%B0%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/04/05/%E6%8C%87%E6%95%B0%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-指数机制与Laplace机制"><a href="#0x00-指数机制与Laplace机制" class="headerlink" title="0x00 指数机制与Laplace机制"></a>0x00 指数机制与Laplace机制</h1><p>在Laplace机制中，我们首先对数据库进行查询，然后再查询结果之上添加一定的噪声使其满足DP的要求。因此，返回的数据通常只是“接近准确”的。那么差分隐私能否允许我们得到真实的结果呢？在这种情况下，指数机制应运而生。</p><p>指数机制（The exponential mechanism）是为我们希望选择“最佳”响应的情况而设计的，但直接在计算数量上添加噪声会完全破坏其价值。例如在拍卖中设定价格，其目标是最大化收益，以及在最优价格上添加少量正噪声（为了保护投标的隐私）可以大大减少由此产生的收入。为了理解接下来我们举个例子：</p><blockquote><p>假设我们有大量的南瓜和四个投标人：A，B，C，D，其中A，B，C各自出价1.00美元，D出价3.01美元。如何制定最优出售价格？假如以 3.01美元出售，则收入为3.01美元（只有D买）；以1.00美元出售，收入为3.00美元（ABC购买）；以3.02美元出售，收入为零！</p></blockquote><p>在这个案例中，每个用户的投标价格是涉及个人隐私的，而对于价格来说，我们自然不希望是加噪声了的。毕竟谁也不希望本来可以3美元出手的南瓜最后只卖了2美元。</p><h1 id="0x01-如何实现指数机制"><a href="#0x01-如何实现指数机制" class="headerlink" title="0x01 如何实现指数机制"></a>0x01 如何实现指数机制</h1><p>指数机制满足$\epsilon-$差分隐私：</p><ul><li>分析者选择一个可能的输出组成的集合 $\mathcal{R}$</li><li>分析者指定一个全局敏感度为 $\Delta\mu$ 的打分函数 $\mu:\mathcal{D}\times \mathcal{R}\rightarrow \mathbb{R}$</li><li>指数机制以正比于 $e^{\frac{\epsilon \mu(x,r)}{2\Delta\mu}}$ 的概率输出 $r\in\mathcal{R}$</li></ul><p>简单来说，这里的 $\mu$ 的作用就是给用户拥有的数据打个分，分越高，表示这个数据越重要（比如上述案例中的价格，可以直接作为 $\mu$ 看待）。因此对于数据集 $X$，我们希望选取的元素有最大效益。</p><p>和Laplace机制一样，我们需要知道 $\mu$ 最大的改变是多少，所以定义：<br>$$<br>\Delta \mu&#x3D;\underset{r\in\mathcal{R},||x-y||_1\leq1}{max} |\mu(x,r)-\mu(y,r)|<br>$$<br>设计指数机制的出发点即对于任意的 $r$，按照 $e^{\frac{\epsilon \mu(x,r)}{2\Delta\mu}}$ 的概率选取最优解即可满足差分隐私要求，因为：<br>$$<br>\ln\frac{e^{\epsilon\cdot\frac{\mu(x\cdot r)}{2\Delta \mu}}}{e^{\epsilon\cdot\frac{\mu(y\cdot r)}{2\Delta \mu}}}&#x3D;\frac{\epsilon[\mu(x,r)-\mu(y,r)]}{\Delta\mu}\leq\epsilon<br>$$<br><strong>规范定义</strong></p><p>设有随机化算法 $M$ 输入为数据集 $X$，输出为一个实体对象 $r\in\mathcal{R}$，$\mu(X,\mathcal{R})$为可用性函数，$\Delta\mu$为函数 $\mu(x,\mathcal{R})$的敏感度，若以正比于$e^{\frac{\epsilon \mu(x,r)}{2\Delta\mu}}$ 的概率从输入中选择并输出 $r$，则算法 $M$ 是满足 $\epsilon-DP$ 的</p><h1 id="0x02-应用案例"><a href="#0x02-应用案例" class="headerlink" title="0x02 应用案例"></a>0x02 应用案例</h1><p>假设某基地正在举办一场体育比赛，可以选择的项目有{足球，排球，篮球，网球}四个项目，参与者们对这些项目进行投票，现在要确定一个项目是的整个决策过程满足$\epsilon$-DP，以每个选项的得票数量作为可用性函数，在给定隐私预算情况下，可以计算选择各个项目的输出概率：</p><img src="/2023/04/05/%E6%8C%87%E6%95%B0%E6%9C%BA%E5%88%B6/image-20230405105514007.png" alt="应用案例" style="zoom:80%;"><p>上述案例中，当 $\epsilon&#x3D;0$ 时，提供完全的隐私保护但数据可用性为0，随着 $\epsilon$ 越大，选择出期望结果的可能性也越大。</p><p><strong>代码实现</strong></p><p>python：</p><pre><code class="python">import numpy as npdef expMechanism(scores,epsilon,sensitivity):    for eps in epsilon:        probability0 = []        probability1 = []        for score in scores:            probability0.append(np.exp(0.5*eps*score/sensitivity))        sum = np.sum(probability0)        # 归一化处理        for i in range(len(probability0)):            probability1.append(probability0[i]/sum)        print(&quot;when epslion=&#123;&#125;,probability1:&quot;.format(e))        print(probability1)if __name__ == &#39;__main__&#39;:    # 打分函数的值    scores = [30,25,8,2]    # 隐私预算epslion    epsilon = [0, 0.1, 1]    sensitivity = 1    expMechanism(scores,epsilon,sensitivity)</code></pre><p>c++：</p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;void expMechanism(int scores[], double epsilons[], int sensitivity, int sco_len, int eps_len)&#123;    double* exponents_list = new double[100];    double sum = 0;    for (int i = 0;i &lt; eps_len;i++)    &#123;        // epsilon相等时        for (int j = 0;j &lt; sco_len;j++)        &#123;            exponents_list[j] = exp(epsilons[i] * scores[j] / (2 * sensitivity));            sum += exponents_list[j];        &#125;        // 归一化        for (int j = 0;j &lt; sco_len;j++)        &#123;            exponents_list[j] = exponents_list[j] / sum;        &#125;        cout &lt;&lt; &quot;epsilon=&quot; &lt;&lt; epsilons[i] &lt;&lt; &quot; probability：&quot;;        for (int j = 0;j &lt; sco_len;j++)        &#123;            cout &lt;&lt; exponents_list[j]&lt;&lt;&quot; &quot;;        &#125;        cout &lt;&lt; endl;        sum = 0;    &#125;    delete[] exponents_list;&#125;int main()&#123;    int scores[4] = &#123; 30, 25, 8, 2 &#125;;    double epsilon[3] = &#123;0, 0.1, 1&#125;;    int sensitivity = 1;    int sco_len = sizeof(scores) / sizeof(int);    int eps_len = sizeof(epsilon) / sizeof(double);    expMechanism(scores, epsilon, sensitivity, sco_len, eps_len);    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h1 id="0x03-指数机制的理论证明"><a href="#0x03-指数机制的理论证明" class="headerlink" title="0x03 指数机制的理论证明"></a>0x03 指数机制的理论证明</h1><img src="/2023/04/05/%E6%8C%87%E6%95%B0%E6%9C%BA%E5%88%B6/image-20230405105629709.png" alt="指数机制的理论证明" style="zoom:80%;"><h1 id="0x04-参考资料"><a href="#0x04-参考资料" class="headerlink" title="0x04 参考资料"></a>0x04 参考资料</h1><ol><li>[DP-指数机制 - 知乎 (zhihu.com)</li><li>[<a href="https://programming-dp.com/cn/ch9.html">指数机制 — 动手学差分隐私 (programming-dp.com)</a></li><li>[<a href="https://juejin.cn/post/6971351045121245215">差分隐私指数机制python代码实现 - 掘金 (juejin.cn)</a></li><li><a href="https://www.cnblogs.com/20189223cjt/p/12155778.html">差分隐私中指数机制的实现 - 20189223 - 博客园 (cnblogs.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 隐私计算 </category>
          
          <category> 差分隐私 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐私计算 </tag>
            
            <tag> 差分隐私 </tag>
            
            <tag> 指数机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密度函数</title>
      <link href="/2023/04/04/%E5%AF%86%E5%BA%A6%E5%87%BD%E6%95%B0/"/>
      <url>/2023/04/04/%E5%AF%86%E5%BA%A6%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概率密度函数"><a href="#概率密度函数" class="headerlink" title="概率密度函数"></a>概率密度函数</h1><p>概率密度函数又称为概率密度</p><p>山峰线</p><h1 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a>分布函数</h1><p>山峰面</p><h1 id="概率分布"><a href="#概率分布" class="headerlink" title="概率分布"></a>概率分布</h1><p>概率分布、分布律、概率函数</p><h1 id="联合概率密度"><a href="#联合概率密度" class="headerlink" title="联合概率密度"></a>联合概率密度</h1><p>拱山峰面</p><p>$f(x,y)$</p><h1 id="联合分布函数"><a href="#联合分布函数" class="headerlink" title="联合分布函数"></a>联合分布函数</h1><p>山峰体<br>$$<br>F(x,y)&#x3D;\int_{-\infty}^{x} \int_{-\infty}^{y}f(u,v)dudv &#x3D;P(X\leq x, Y\leq y)<br>$$</p><h1 id="联合分布律"><a href="#联合分布律" class="headerlink" title="联合分布律"></a>联合分布律</h1><h1 id="边缘概率密度"><a href="#边缘概率密度" class="headerlink" title="边缘概率密度"></a>边缘概率密度</h1><p>$$<br>f_X(x)&#x3D;\int_{- \infty}^{ +\infty}f(x,y)dy\<br>f_Y(y)&#x3D;\int_{- \infty}^{ +\infty}f(x,y)dx<br>$$</p><p>边缘分布函数</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
          <category> 概率论与数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论与数理统计 </tag>
            
            <tag> 密度函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>熵以及KL散度等概念</title>
      <link href="/2023/04/04/%E7%86%B5%E4%BB%A5%E5%8F%8AKL%E6%95%A3%E5%BA%A6%E7%AD%89%E6%A6%82%E5%BF%B5/"/>
      <url>/2023/04/04/%E7%86%B5%E4%BB%A5%E5%8F%8AKL%E6%95%A3%E5%BA%A6%E7%AD%89%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h1><p><strong>熵</strong>是一个物理学概念，它表示一个系统的不确定性程度，或者说是一个系统的混乱程度。</p><p><strong>信息熵</strong>是一个叫香农的美国数学家将熵引入信息论中，并将它命名为“香农熵”或“信息熵”。</p><p>熵与信息熵就好比帅哥与靓仔，实质上是指同一个东西，只是不同领域的叫法不一样。</p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>$$<br>H(x)&#x3D;-\sum_{i&#x3D;1}^np(x_i)\log p(x_i)<br>$$</p><ul><li>$n$：随机变量可能的取值数</li><li>$x$：随机变量</li><li>$P(x)$：随机变量 $x$ 的概率函数</li></ul><h2 id="Renyi-Entropy-瑞丽熵"><a href="#Renyi-Entropy-瑞丽熵" class="headerlink" title="Renyi Entropy 瑞丽熵"></a>Renyi Entropy 瑞丽熵</h2><p><img src="/./%E7%86%B5%E4%BB%A5%E5%8F%8AKL%E6%95%A3%E5%BA%A6%E7%AD%89%E6%A6%82%E5%BF%B5/image-20230404153813768.png" alt="image-20230404153813768"></p><img src="/2023/04/04/%E7%86%B5%E4%BB%A5%E5%8F%8AKL%E6%95%A3%E5%BA%A6%E7%AD%89%E6%A6%82%E5%BF%B5/image-20230404153942618.png" alt="image-20230404153942618" style="zoom:80%;"><h1 id="KL散度"><a href="#KL散度" class="headerlink" title="KL散度"></a>KL散度</h1><p>KL散度就是两个概率分布间差异的<strong>非对称性</strong>度量。通俗的讲，KL散度是用来衡量同一个随机变量的两个不同分布之间的<strong>距离</strong>。<br>$$<br>D_{KL}(p||q)&#x3D;\sum_{i&#x3D;1}^np(x_i)log(\frac{p(x_i)}{q(x_i)})<br>$$<br>特性1：非对称性</p><ul><li>$D_{KL}(p||q)\neq D_{KL}(q||p)$</li><li>$P$ 和 $Q$ 的概率分布完全一样才相等</li></ul><p>特性2：非负性（吉布斯不等式推导）</p><ul><li>$D_{KL}(p||q)$ 恒大于等于0</li><li>$P$ 和 $Q$ 的概率分布完全一样才等于0</li></ul><img src="/2023/04/04/%E7%86%B5%E4%BB%A5%E5%8F%8AKL%E6%95%A3%E5%BA%A6%E7%AD%89%E6%A6%82%E5%BF%B5/image-20230404145744032.png" alt="image-20230404145744032" style="zoom:50%;"><p><strong>KL散度公式变形</strong><br>$$<br>D_{KL}(p||q) &#x3D; \sum_{i&#x3D;1}^np(x_i)log(\frac{p(x_i)}{q(x_i)})\&#x3D;\sum_{i&#x3D;1}^np(x_i)logp(x_i)-p(x_i)logq(x_i)\&#x3D;-(-\sum_{i&#x3D;1}^np(x_i)logp(x_i))-\sum_{i&#x3D;1}^np(x_i)logq(x_i)\&#x3D;H(P,Q)-H(P)<br>$$<br>即KL散度就是 <code>交叉熵-信息熵</code></p><h1 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h1><p>交叉熵主要用于度量一个随机变量X的预测分布Q与真实分布P之间的差距。差距可以理解为距离、误差、失望值、困难程度、混乱程度、一辆车、一套房等<br>$$<br>H(P,Q)&#x3D;\sum_{i&#x3D;1}^np(x_i)\log q(x_i)\<br>H(P,Q)&#x3D;\sum_xp(x)\log (\frac{1}{q(x)})<br>$$<br><img src="/2023/04/04/%E7%86%B5%E4%BB%A5%E5%8F%8AKL%E6%95%A3%E5%BA%A6%E7%AD%89%E6%A6%82%E5%BF%B5/image-20230404151231817.png" alt="image-20230404151231817" style="zoom:80%;"></p><p>结论1：预测越准确，交叉熵越小</p><p>结论2：交叉熵只跟真实标签的预测概率值有关</p><p><strong>交叉熵的最简公式</strong><br>$$<br>Cross_Entropy(p,q)&#x3D;-\log q(c_i)<br>$$<br>其中， $c_i$ 是正确标签</p><img src="/2023/04/04/%E7%86%B5%E4%BB%A5%E5%8F%8AKL%E6%95%A3%E5%BA%A6%E7%AD%89%E6%A6%82%E5%BF%B5/image-20230404151809537.png" alt="image-20230404151809537" style="zoom:80%;"><img src="/2023/04/04/%E7%86%B5%E4%BB%A5%E5%8F%8AKL%E6%95%A3%E5%BA%A6%E7%AD%89%E6%A6%82%E5%BF%B5/image-20230404151954984.png" alt="image-20230404151954984" style="zoom:80%;"><p><img src="/./%E7%86%B5%E4%BB%A5%E5%8F%8AKL%E6%95%A3%E5%BA%A6%E7%AD%89%E6%A6%82%E5%BF%B5/image-20230404152343746.png"></p><p><img src="/./%E7%86%B5%E4%BB%A5%E5%8F%8AKL%E6%95%A3%E5%BA%A6%E7%AD%89%E6%A6%82%E5%BF%B5/image-20230404152433530.png" alt="image-20230404152433530"></p><p><img src="/./%E7%86%B5%E4%BB%A5%E5%8F%8AKL%E6%95%A3%E5%BA%A6%E7%AD%89%E6%A6%82%E5%BF%B5/image-20230404152451677.png" alt="image-20230404152451677"></p><p><img src="/./%E7%86%B5%E4%BB%A5%E5%8F%8AKL%E6%95%A3%E5%BA%A6%E7%AD%89%E6%A6%82%E5%BF%B5/image-20230404152459444.png" alt="image-20230404152459444"></p><p><img src="/./%E7%86%B5%E4%BB%A5%E5%8F%8AKL%E6%95%A3%E5%BA%A6%E7%AD%89%E6%A6%82%E5%BF%B5/image-20230404152529423.png" alt="image-20230404152529423"></p><p><img src="/./%E7%86%B5%E4%BB%A5%E5%8F%8AKL%E6%95%A3%E5%BA%A6%E7%AD%89%E6%A6%82%E5%BF%B5/image-20230404152841339.png" alt="image-20230404152841339"></p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
          <category> 密码学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KL散度 </tag>
            
            <tag> 熵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分隐私</title>
      <link href="/2023/04/04/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81/"/>
      <url>/2023/04/04/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-什么是差分隐私"><a href="#0x00-什么是差分隐私" class="headerlink" title="0x00 什么是差分隐私"></a>0x00 什么是差分隐私</h1><p><code>差分隐私</code>顾名思义就是用来防范<code>差分攻击</code>的，我最早接触到<code>差分攻击</code>的概念是数据库课上老师介绍的。举个简单的例子，假设现在有一个婚恋数据库，2个单身8个已婚，只能查有多少人单身。刚开始的时候查询发现，2个人单身；现在张三跑去登记了自己婚姻状况，再一查，发现3个人单身。所以张三单身。</p><img src="/2023/04/04/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81/image-20230404154628624.png" alt="图1-1 差分攻击示意图" style="zoom:80%;"><p>这里张三作为一个样本的的出现，使得攻击者获得了奇怪的知识。而差分隐私需要做到的就是使得攻击者的知识不会因为这些新样本的出现而发生变化。</p><p>那怎么做到让攻击者不知道张三是否单身呢？加入随机噪声。比如刚才的例子，本来两次查询结构是确定的2和3，现在加入随机噪声后，变成了两个随机变量，画出它们概率分布图。</p><img src="/2023/04/04/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81/image-20230404154740642.png" alt="图1-2 概率分布图" style="zoom:80%;"><p>现在，如果张三不在数据库的话，得到结果可能是2.5；张三在的话，得到的结果也可能是2.5；两个数据集查询得到某一个结果的概率很接近，以至于我们根本分不清这个结果来自于哪一个数据集，这样也就实现了攻击者的知识不会因为张三这个样本的出现与否而发生变化。</p><p>这些只是概念上的理解，总结一下就是对查询的<strong>结果</strong>加入噪声，使得攻击者无法辨别某一样本是否在数据集中。一个形象的说法就是，双兔傍地走安能辨我是雄雌。</p><h1 id="0x01-数学定义"><a href="#0x01-数学定义" class="headerlink" title="0x01 数学定义"></a>0x01 数学定义</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>对于一个有限域 $\mathbb{Z}$，$z\in \mathbb{Z}$ 为 $\mathbb{Z}$ 中的元素，从 $\mathbb{Z}$ 中抽样所得 $z$ 的集合组成数据集 $D$ ，其样本量为 $n$ ， 属性的个数为维度 $d$。</p><p>对数据集 $D$ 的各种映射函数被定义为<strong>查询</strong>（Query），用 $F&#x3D;{f_1, f_2, ······}$ 来表示一组查询，其中 $f(x):x\rightarrow R$ 。算法 $M$ 对查询 $F$ 的结果进行处理，使之满足隐私保护的条件，此过程称为隐私保护机制，即 $M(x) &#x3D; f(x)+r$，其中 $r$ 是随机噪声，$M(x)$ 是经过隐私保护的最终查询结果。</p><p>设数据集 $D$ 与 $D’$ ，具有相同的属性结构，两者的对称差记作 $D\Delta D’$，$|D\Delta D’|$ 表示 $D\Delta D’$ 中记录的数量。若 $|D\Delta D’|&#x3D;1$，则称 $D$ 和 $ D’$ 为<strong>邻近数据集</strong>。</p><h2 id="严格差分隐私"><a href="#严格差分隐私" class="headerlink" title="严格差分隐私"></a>严格差分隐私</h2><p>设有随机算法 $M$，$P_M$ 为 $M$ 所有可能的输出构成的集合．对于任意两个邻近数据集 $D$ 和 $D’$ 以及 $P_M$ 的任何子集 $S_M$，若算法 $M$ 满足<br>$$<br>Pr[M(D)\in S_M] \leq e^\varepsilon \times Pr[M(D’)\in S_M]<br>$$<br>则称算法 $M$ 提供 $\varepsilon- $差分隐私，其中参数 $\varepsilon $ 被称为<strong>隐私保护预算</strong>。 $\varepsilon$ 越小，隐私保护就越好，但是加入的噪声会越大，数据的可用性越差。</p><p>该公式是如何得来的呢？</p><p>根据图1-2，我们想要使攻击者无法区分这两个概率分布，即我们需要使这两个分布尽可能的接近，即这两个分布的差异尽可能的小。对于分布之间的差异，自然会想到<strong>KL散度</strong>：<br>$$<br>D_{KL}(p||q)&#x3D;\sum_{i&#x3D;1}^np(x_i)log(\frac{p(x_i)}{q(x_i)})<br>$$<br>但是我们并不关心这两个分布的整体差异，我们只关注差异最大的情况下能够被 <code>bound</code> 住，所以引入 <code>max-divergence</code> （最大散度），令其小于一个阈值 $\varepsilon $：<br>$$<br>D_{\infty}(Y||Z) &#x3D; \underset{S\subset Supp(Y)}{max} [ln\frac{Pr[Y\in S]}{Pr[Z\in S]}] &#x3D; \underset{y\in Y}{max}[ln\frac{Pr[y&#x3D;Y]}{Pr[Z&#x3D;y]}]\leq \varepsilon<br>$$<br>上面公式进行化简得到了差分隐私的公式：<br>$$<br>\frac{Pr[y&#x3D;Y]}{Pr[Z&#x3D;y]}\leq e^\varepsilon\Longrightarrow Pr[y&#x3D;Y]\leq e^\varepsilon\times Pr[Z&#x3D;y]<br>$$</p><h2 id="松弛差分隐私"><a href="#松弛差分隐私" class="headerlink" title="松弛差分隐私"></a>松弛差分隐私</h2><p>上面定义的差分隐私太过严格，在实际的应用中需要很多的隐私预算。因此为了算法的实用性，<code>Dwork</code>后面引入了松弛版本的差分隐私：<br>$$<br>Pr[M(D)\in S_M] \leq e^\varepsilon \times Pr[M(D’)\in S_M]+\delta<br>$$<br>通过最大散度来理解：<br>$$<br>D_{\infty}^{\delta}(Y||Z) &#x3D; \underset{S\subset Supp(Y);Pr[Y\in S]\geq \delta}{max} [ln\frac{Pr[Y\in S]-\delta}{Pr[Z\in S]}]\leq \varepsilon<br>$$<br>相比较于原始的式子，对分子减去了一个 $\delta$，也就是说我们可以容忍一个较小的差距。</p><p>直观形式如下图，像图中标注的位置，本来 $\varepsilon $ 是无法 <code>bound</code> 住，但是我们考虑松弛项 $\delta$ ，整体依旧满足差分隐私。一般 $\delta$ 都设置的比较小。</p><img src="/2023/04/04/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81/image-20230404161603967.png" alt="图3-1 松弛差分隐私" style="zoom:80%;"><p>除了 <code>Dwork</code> 这里定义的松弛差分隐私，后面有许多工作都在围绕着如何定义出松弛的差分隐私，比如利用 <a href="https://link.zhihu.com/?target=https://www.researchgate.net/publication/320093723_Renyi_Differential_Privacy">Rényi Differential Privacy</a>，privacy-loss的矩[<a href="https://www.zhihu.com/people/chen-ming-xin-65/posts#ref_2">2]</a>。整体实现的目标就是，可以利用更少的隐私预算，得到相同的噪声尺度。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="隐私保护预算"><a href="#隐私保护预算" class="headerlink" title="隐私保护预算"></a>隐私保护预算</h3><p>隐私保护预算 $ε$ 用来控制算法 $M$ 在两个邻近数据集上获得相同输出的概率比值，它事实上体现了 $M$ 所能够提供的隐私保护水平。在实际应用中，$ε$ 通常取很小的值（0.1到1），例如 $0.01$，$0.1$，或者 $ln2$，$ln3$等。ε越小，表示隐私保护水平越高．当ε等于０时，保护水平达到最高，此时对于任意邻近数据集，算法都将输出两个概率分布完全相同的结果，这些结果也不能反映任何关于数据集的 有用的信息．因此，ε的取值要结合具体需求来达到输出结果的安全性与可用性的平衡。</p><h1 id="0x02-敏感度"><a href="#0x02-敏感度" class="headerlink" title="0x02 敏感度"></a>0x02 敏感度</h1><p>差分隐私保护可以通过在查询函数的返回值中加入适量的干扰噪声来实现。加入噪声过多会影响结果的可用性，过少则无法提供足够的安全保障。敏感度是决定加入噪声量大小的关键参数，它指删除数据集中任一记录对查询结果造成的<strong>最大改变</strong>。换句话说，敏感度越大，我们需要加入的噪声就越大（因为我们需要弥补这个差距）。 函数的敏感度反映了函数输入发生变化时对应输出的变化程度。在差分隐私保护方法中定义了两种敏感度，即全局敏感度（<code>Global Sensitivity</code>）和局部敏感度（<code>Local Sensitivity</code>）。</p><h2 id="2-1-全局敏感度"><a href="#2-1-全局敏感度" class="headerlink" title="2.1 全局敏感度"></a>2.1 全局敏感度</h2><p>给定一个数据集 $\mathcal{D}$ 映射为实数的函数 $f:\mathcal{D}\rightarrow \mathbb{R}$，$f$ 的 <code>全局敏感度（Global Sensitivity）</code> 为<br>$$<br>\Delta f&#x3D;GS(f)&#x3D;\underset{D,D’:d(D,D’)\leq 1}{max} |f(D)-f(D’)|<br>$$<br>全局敏感度的定义告诉我们，对于任意两个相邻数据集 $D$ 和 $D’$，函数 $f(x)$ 和 $f(x’)$ 的输出最多相差 $GS(f)$。此敏感度的定义与具体查询的数据集无关（对于任意的两个相邻数据集都成立），因此我们把这一敏感度称为<strong>全局敏感度</strong>。</p><h2 id="2-2-局部敏感度"><a href="#2-2-局部敏感度" class="headerlink" title="2.2 局部敏感度"></a>2.2 局部敏感度</h2><p>局部敏感度（Local Sensitivity）的想法是将两个数据集中的一个作为待查询的实际数据集，仅考虑此数据集的所有临近数据集。</p><p>用更严谨的数学语言来描述，函数 $f:\mathcal{D}\rightarrow \mathbb{R}$ 在 $x:\mathcal{D}$ 的局部敏感度定义如下：<br>$$<br>\Delta f&#x3D;LS(f,x) &#x3D;\underset{D’:d(D,D’)\leq 1}{max} |f(D)-f(D’)|<br>$$<br>需要注意的是，局部敏感度是以查询函数 $f$ 和实际数据集 $D$ 这两个作为输入所定义的函数。与全局敏感度不同，我们不 能抛开输入的数据集而单独讨论局部敏感度。反之，我们需要考虑局部敏感度所依赖的实际数据集是什么。</p><h2 id="2-3-计算敏感度"><a href="#2-3-计算敏感度" class="headerlink" title="2.3 计算敏感度"></a>2.3 计算敏感度</h2><p>对于一些实数域上的简单函数：</p><ul><li>$f(x)&#x3D;x$ 的全局敏感度是1，因为 $x$ 变化（增大或减少）1，$f(x)$ 也变化1</li><li>$f(x)&#x3D;x+x$ 的全局敏感度是2，因为 $x$ 变化1，$f(x)$ 变化2</li><li>$f(x)&#x3D;5\cdot x$ 的全局敏感度是5，因为 $x$ 变化1，$f(x)$ 变化5</li><li>$f(x)&#x3D;x*x$ 的全局敏感度是无感的，因为 $f(x)$ 的变化取决于 $x$ 的值</li></ul><h3 id="2-3-1-计数查询"><a href="#2-3-1-计数查询" class="headerlink" title="2.3.1 计数查询"></a>2.3.1 计数查询</h3><p>计数查询（数据库SQL中的 <code>COUNT</code> 函数）计算数据集中满足特定属性的行数。一般来说，计数查询的敏感度总等于1。这是因为向数据集中添加一行数据最多会使查询的输出结果增加1，即当新增行满足特定属性 时，计数结果加1。反之，当新增行不满足特定属性时，计数结果不变（删除行可能使计数结果减1）。</p><p>假设有一个数据集 $D&#x3D;{a,a,a,a}$ 和数据集 $D’&#x3D;{a,a,a,b}$，比如现在的 $f$ 为计数函数，则 $f(a)<em>D&#x3D;4,f(a)</em>{D’}&#x3D;3$，所以敏感度为1</p><h3 id="2-3-2-求和查询"><a href="#2-3-2-求和查询" class="headerlink" title="2.3.2 求和查询"></a>2.3.2 求和查询</h3><p>求和问询（数据库SQL中的 <code>SUM</code> 算子）计算数据集行中的属性值（Attribute Values）总和。</p><p>假设有一个数据集 $D&#x3D;{a,a,a,a}$ 和数据集 $D’&#x3D;{a,a,a,b}$，比如现在的 $f$ 为计数函数，则 $f(D)&#x3D;4a,f(D’)&#x3D;3a+b$，所以敏感度为 $b-a$</p><h3 id="2-3-3-平均查询"><a href="#2-3-3-平均查询" class="headerlink" title="2.3.3 平均查询"></a>2.3.3 平均查询</h3><p>均值问询（数据库SQL中的 <code>AVG</code> 算子）计算指定列属性值的平均值。</p><p>假设有一个数据集 $D&#x3D;{a,a,a,a}$ 和数据集 $D’&#x3D;{a,a,a,b}$，比如现在的 $f$ 为计数函数，则 $f(D)&#x3D;\frac{4a}{4}&#x3D;a,f(D’)&#x3D;\frac{3a+b}{4}$，所以敏感度为 $f(D’)-f(D)&#x3D;\frac{b-a}{4}$</p><h1 id="0x02-三种机制"><a href="#0x02-三种机制" class="headerlink" title="0x02 三种机制"></a>0x02 三种机制</h1><p>在应用差分隐私进行隐私保护中，需要处理的数据主要分为两大类，一类是<code>数值型</code>的数据，比如说数据集中已婚人士的数量；另外一类是<code>非数值型</code>的数据，比如喜欢人数最多的颜色。这两者，主体分别是 <code>数量(连续数据)</code> 和 <code>颜色(离散数据)</code>。</p><ul><li>对于 <code>数值型</code> 数据，一般采用 <code>Laplace</code> 或者 <code>高斯</code> 机制，对得到的数值结果加入随机噪声即可实现差分隐私</li><li>对于 <code>非数值型</code> 数据，一般采用 <code>指数</code> 机制并引入一个 <code>打分函数</code>，对每一种可能的输出都得到一个分数，归一化后作为查询返回的概率值。比如现在有<code>&#123;红色:20, 绿色:30, 紫色:50&#125;</code>，将数量作为 <code>打分函数</code>，那么得到的对应输出概率为 <code>红色:3e-7, 绿色:4e-5, 紫色:0.999</code>。当接收到一个查询后，就以对应的概率值返回结果</li></ul><h2 id="2-1-数值型查询"><a href="#2-1-数值型查询" class="headerlink" title="2.1 数值型查询"></a>2.1 数值型查询</h2><h3 id="2-1-2-高斯机制"><a href="#2-1-2-高斯机制" class="headerlink" title="2.1.2 高斯机制"></a>2.1.2 高斯机制</h3><p><strong>高斯分布（正态分布）</strong><br>$$<br>P_{\mu,\sigma^2}(x)&#x3D;\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}<br>$$<br><strong>高斯机制</strong></p><p>高斯机制是拉普拉斯机制的替代方案，不同在于加的是高斯噪声而不是拉普拉斯噪声。高斯机制不满足纯 $\epsilon-$差分隐私，但是满足 $(\epsilon,\delta)-$差分隐私。 根据高斯机制，对于返回数字的函数 $f(x)$，以下 $M(x)$ 定义满足 $(\epsilon,\delta)-$差分隐私：<br>$$<br>M(x)&#x3D; f(x)+N(0,\sigma^2)<br>$$<br>其中<br>$$<br>\sigma^2&#x3D;\frac{2\Delta f^2\log (\frac{1.25}{\delta})}{\epsilon^2}<br>$$<br>其中，$s$ 是 $f$ 的敏感度，$N(0,\sigma^2)$ 表示均值为0，方差为 $\sigma^2$ 的高斯（正态）分布采样结果。</p><p><strong>敏感度</strong>定义如下：<br>$$<br>\Delta f&#x3D;\underset{D,D’:d(D,D’)\leq 1}{max} ||f(D)-f(D’)||_2<br>$$<br>与拉普拉斯敏感度定义不同，这里使用的是 <code>L2范数</code>，这与两个分布的形式有关，主要的目的也是为了方便后面差分隐私的证明。</p><p><strong>缺点</strong></p><ol><li>高斯机制需要使用松弛 $(\sigma, \delta)-$差分隐私定义</li><li>该机制的准确性不如拉普拉斯机制</li></ol><h2 id="2-2-非数值型查询–指数机制"><a href="#2-2-非数值型查询–指数机制" class="headerlink" title="2.2 非数值型查询–指数机制"></a>2.2 非数值型查询–指数机制</h2><h1 id="0x03-Reference"><a href="#0x03-Reference" class="headerlink" title="0x03 Reference"></a>0x03 Reference</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/144318152">https://zhuanlan.zhihu.com/p/144318152</a></li><li><a href="https://zhuanlan.zhihu.com/p/445642473">差分隐私的常用机制 - 知乎 (zhihu.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
          <category> 隐私计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐私计算 </tag>
            
            <tag> 差分隐私 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字签名</title>
      <link href="/2023/03/27/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
      <url>/2023/03/27/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="数字签名（DSA）"><a href="#数字签名（DSA）" class="headerlink" title="数字签名（DSA）"></a>数字签名（DSA）</h1><p>数字签名就是签名方用自己的私钥签名，验证方用签名方的公钥验证。</p><h2 id="1-椭圆曲线数字签名（ECDSA）"><a href="#1-椭圆曲线数字签名（ECDSA）" class="headerlink" title="1 椭圆曲线数字签名（ECDSA）"></a>1 椭圆曲线数字签名（ECDSA）</h2><p><a href="https://www.instructables.com/Understanding-how-ECDSA-protects-your-data/">参考链接：Understanding How ECDSA Protects Your Data</a></p><h3 id="1-1-什么是ECDSA"><a href="#1-1-什么是ECDSA" class="headerlink" title="1.1 什么是ECDSA"></a>1.1 什么是ECDSA</h3><p><code>ECDSA</code>是 <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">Elliptic Curve Digital Signature Algorithm</a>（椭圆曲线数字签名）的简称，主要用于对数据（比如一个文件）创建数字签名，以便于你在不破坏它的安全性的前提下对它的真实性进行验证。可以将它想象成一个实际的签名，你可以识别部分人的签名，但是你无法在别人不知道的情况下伪造它。而ECDSA签名和真实签名的区别在于，伪造ECDSA签名是根本不可能的。</p><h3 id="1-2-原理"><a href="#1-2-原理" class="headerlink" title="1.2 原理"></a>1.2 原理</h3><p>原理非常简单，有一个数学方程，在图上画了一条曲线，然后你在这条曲线上面随机选取了一个点作为你的 <code>原点(point of origin)</code>。接着你产生了一个随机数，作为你的 <code>私钥(Private key)</code>，最后你用上面的随机数和原点通过一些复杂的魔法数学方程得到该条曲线上面的第二个点，这是你的 <code>公钥(Public key)</code>。</p><p>当你想要对一个文件进行签名的时候，你会用这个私钥（随机数）和文件的哈希（一串独一无二的代表该文件的数）组成一个魔法数学方程，这就是你的签名。签名本身将被分成两部分，称为 <code>R</code> 和 <code>S</code> 。为了验证签名的正确性，你只需要公钥（用私钥在曲线上面产生的点）并将公钥和签名的一部分 <code>S</code> 一起代入另外一个方程，如果这个签名是由私钥正确签名过的数字签名，那么它将给出签名的另外一部分 <code>R</code>。简单来说，一个数字签名包含两个数字：<code>R</code>和<code>S</code>。你使用一个私钥来产生<code>R</code>和<code>S</code>，如果将公钥和 <code>S</code> 代入被选定的魔法数学方程给出 <code>R</code> 的话，这个签名就是有效的。仅仅知道公钥是无法知道私钥或者创建出数字签名。</p><h3 id="1-3-为什么使用ECDSA"><a href="#1-3-为什么使用ECDSA" class="headerlink" title="1.3 为什么使用ECDSA"></a>1.3 为什么使用ECDSA</h3><p>对于 <code>ECDSA</code> 算法，需要知道以下参数：</p><ul><li><code>a b</code>：椭圆曲线方程 $y^2&#x3D;x^3+a\cdot x+b$ 的参数</li><li><code>p</code>：模运算的底</li><li><code>N</code>：椭圆曲线上点的个数</li><li><code>G</code>：选中的参考的起点，可以是曲线上的任意一点</li></ul><p>总结一下：首先，你有一对密钥：公钥和私钥，私钥是一个随机数，也是160比特大小，公钥是将曲线上的点 $G$ 与私钥相乘以后的曲线上的点。令 $dA$ 表示私钥，一个随机数，$Qa$ 表示公钥，曲线上面的一个点，我们有 $Qa&#x3D;dA\cdot G$，其中 $G$ 是曲线上面的参考点。</p><h3 id="1-4-哈希函数–SHA1"><a href="#1-4-哈希函数–SHA1" class="headerlink" title="1.4 哈希函数–SHA1"></a>1.4 哈希函数–SHA1</h3><h3 id="1-5-签名"><a href="#1-5-签名" class="headerlink" title="1.5 签名"></a>1.5 签名</h3><p>签名本身是40字节，由各20字节的值来进行表示。第一个值为 $R$，第二个为 $S$。值对 $(R,S)$ 就是 <code>ECDSA</code> 签名。</p><p>如何创建这一值对：</p><ul><li>生成一个20字节的随机数 $k$</li><li>利用点乘法计算 $P &#x3D; k\cdot G$，其中 $P$ 的<strong>横坐标</strong>就是 $R$</li><li>利用SHA1计算信息 $m$ 的哈希，得到一个20字节的巨大的整数 $z$</li><li>计算 $S&#x3D;k^{-1}(z+dA\cdot R)mod\ p$</li></ul><p>其中 $k$ 是用来生成 $R$ 的随机数，$k^{-1}$ 是 $k$ 的模的乘法逆元。</p><h3 id="1-6-验证签名"><a href="#1-6-验证签名" class="headerlink" title="1.6 验证签名"></a>1.6 验证签名</h3><p>只需要计算<br>$$<br>P’&#x3D;S^{-1}\cdot z\cdot G+S^{-1}\cdot R\cdot Qa<br>$$<br>如果 $P’$ 的横坐标等于 $R$，就说明签名是有效的。</p><p><strong>推导过程：</strong><br>$$<br>P’&#x3D;S^{-1}\cdot z\cdot G+S^{-1}\cdot R\cdot Qa&#x3D;S^{-1}\cdot z\cdot G+S^{-1}\cdot R\cdot dA\cdot G&#x3D;S^{-1}\cdot G(z+R\cdot dA)&#x3D;k\cdot G&#x3D;P<br>$$</p><h2 id="2-素数群数字签名（DSA）"><a href="#2-素数群数字签名（DSA）" class="headerlink" title="2 素数群数字签名（DSA）"></a>2 素数群数字签名（DSA）</h2><p>素数群 $G$ 的阶为 $q$，生成元为 $g$，哈希函数 $H:{0,1}^*\to \mathbb{Z}_q $，哈希函数 $H^{‘}:G\to\mathbb{Z}_q$</p><p><strong>密钥生成：</strong></p><p>私钥为随机数 $x\in\mathbb{Z}_q$，公钥为 $y$，其中 $y&#x3D;g^x$</p><p><strong>签名：</strong></p><p>对于消息 $m\in\mathbb{Z}_q$，选择随机数 $k\in\mathbb{Z}_q$，计算 $R&#x3D;g^{k^{-1}}$，计算 $r&#x3D;H^{‘}(R)$，计算 $s&#x3D;k(m+xr)mod\ q$，则最终的签名为 $(r,s)$</p><p><strong>验证：</strong></p><p>校验 $(r,s)$ 的取值范围 $\mathbb{Z}_q$，计算 $R^{‘}&#x3D;g^{ms^{-1}mod\ q}y^{rs^{-1}mod\ q}$，校验 $r\overset{?}{&#x3D;} H’(R’)$</p><p><strong>公式推导：</strong><br>$$<br>R’&#x3D;g^{ms^{-1}mod\ q}y^{rs^{-1}mod\ q}&#x3D;g^{ms^{-1}mod\ q}g^{xrs^{-1}mod\ q}&#x3D;g^{s^{-1}(m+xr)mod\ q}&#x3D;g^{k^{-1}}&#x3D;R<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
          <category> 密码学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字签名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2023/03/27/Git/"/>
      <url>/2023/03/27/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1-版本控制"><a href="#1-版本控制" class="headerlink" title="1 版本控制"></a>1 版本控制</h2><p>版本控制是一种记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的系统</p><h3 id="1-1-集中式版本控制"><a href="#1-1-集中式版本控制" class="headerlink" title="1.1 集中式版本控制"></a>1.1 集中式版本控制</h3><p>集中化的版本控制系统诸如 CVS，SVN 以及 Perforce 等，都有一个单一的集 中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</p><h3 id="1-2-分布式版本控制"><a href="#1-2-分布式版本控制" class="headerlink" title="1.2 分布式版本控制"></a>1.2 分布式版本控制</h3><h2 id="2-初始化配置"><a href="#2-初始化配置" class="headerlink" title="2 初始化配置"></a>2 初始化配置</h2><p><strong>命令：</strong></p><ul><li><code>git config --global user.name &quot;zhliu9802&quot;</code> ：配置用户信息中的用户名为 <code>zhliu9802</code></li><li><code>git config --list</code>：查看所有范围的配置信息</li><li><code>git config --list --local</code>：只看对当前仓库有效的配置信息，<code>--local</code> 可以更改为 <code>--global</code> 、<code>--system</code></li><li><code> git config --global --unset user.name</code>：删除配置信息中的用户名信息</li></ul><blockquote><ol><li><code>--global</code>：对当前用户所有的仓库都有效，读写的是<code>~/.gitconfig</code> 文件</li><li><code>--local</code>：只对当前仓库有效，也是默认的，必须在一个 <code>git</code> 仓库中才能使用，读写的是 <code>./git/config</code> 文件</li><li><code>--system</code>：对系统所有登录的用户有效，基本不用，读写的是 <code>/etc/gitconfig</code></li></ol><p>注意：<code>local</code> 的优先级最高，其次是 <code>global</code>，最后是 <code>system</code></p></blockquote><p><strong>案例1：</strong>配置用户信息，如用户名和邮箱</p><pre><code class="bash">$ git config --global user.name &quot;zhliu9802&quot;$ git config --global user.email &quot;zhliu9802@163.com&quot;</code></pre><p><strong>案例2：</strong>查看当前配置信息</p><pre><code class="bash"># 查看已有的配置信息$ git config --list --global# 输出diff.astextplain.textconv=astextplainfilter.lfs.clean=git-lfs clean -- %ffilter.lfs.smudge=git-lfs smudge -- %ffilter.lfs.process=git-lfs filter-processfilter.lfs.required=truehttp.sslbackend=opensslhttp.sslcainfo=F:/Software/Git/mingw64/etc/ssl/certs/ca-bundle.crtcore.autocrlf=truecore.fscache=truecore.symlinks=falsepull.rebase=falsecredential.helper=managercredential.https://dev.azure.com.usehttppath=trueinit.defaultbranch=masteruser.name=zhliu9802user.email=zhliu9802@163.com</code></pre><p><strong>案例3：</strong>删除案例2中设置的用户名，并查看删除后的配置信息</p><pre><code class="bash"># 删除配置信息$ git config --global --unset user.name$ git config --list --global# 输出diff.astextplain.textconv=astextplainfilter.lfs.clean=git-lfs clean -- %ffilter.lfs.smudge=git-lfs smudge -- %ffilter.lfs.process=git-lfs filter-processfilter.lfs.required=truehttp.sslbackend=opensslhttp.sslcainfo=F:/Software/Git/mingw64/etc/ssl/certs/ca-bundle.crtcore.autocrlf=truecore.fscache=truecore.symlinks=falsepull.rebase=falsecredential.helper=managercredential.https://dev.azure.com.usehttppath=trueinit.defaultbranch=masteruser.email=zhliu9802@163.com</code></pre><h2 id="3-Git底层概念（底层命令）"><a href="#3-Git底层概念（底层命令）" class="headerlink" title="3 Git底层概念（底层命令）"></a>3 Git底层概念（底层命令）</h2><h3 id="3-1-git目录"><a href="#3-1-git目录" class="headerlink" title="3.1 .git目录"></a>3.1 .git目录</h3><ul><li><code>HEAD</code>：存放<code>HEAD</code>指针当前指向的引用，即告诉我们当前工作在哪个分支</li><li><code>config</code>：存放本地仓库的配置信息，只有指定配置信息为<code>--local</code>时才会发生改变</li><li><code>refs</code>：包含 <code>heads</code> 和 <code>tags</code> ，<code>heads</code> 存放分支文件，里边有具体的分支文件，其中每个分支保存了一个哈希值</li><li><code>objects</code>：git数据库</li><li><code>index</code>：git暂存区</li></ul><h3 id="3-2-区域和对象"><a href="#3-2-区域和对象" class="headerlink" title="3.2 区域和对象"></a>3.2 区域和对象</h3><h4 id="3-2-1-区域"><a href="#3-2-1-区域" class="headerlink" title="3.2.1 区域"></a>3.2.1 区域</h4><ul><li><strong>工作区</strong>：沙箱环境</li><li><strong>暂存区</strong></li><li><strong>版本库</strong></li></ul><h4 id="3-2-2-对象"><a href="#3-2-2-对象" class="headerlink" title="3.2.2 对象"></a>3.2.2 对象</h4><h5 id="3-2-2-1-git对象"><a href="#3-2-2-1-git对象" class="headerlink" title="3.2.2.1 git对象"></a>3.2.2.1 git对象</h5><p>git对象是 <code>key:value</code> 组成的键值对，<code>key</code> 是 <code>value</code> 对应的哈希值，键值对在git内部是一个 <code>blob</code> 类型。git对象只能存储内容，并不能代表项目的一个版本</p><p><strong>git对象创建时机：</strong></p><ul><li>当将文件或者从控制台输入的内容被git所管理时，git就会在内部创建git对象</li><li>当文件内容被修改（也可以被看作是更新了一个版本），重新写入版本库时，也会生成新的git对象</li></ul><p><strong>操作：</strong></p><pre><code class="bash">$ git init # 直接从控制台写入git对象# -w：写入数据对象到git数据库，若不指定该选项，则只会输出内容所对应的hash值# --stdin：从标准输入流中读取内容$ echo &quot;test content&quot; | git hash-object -w --stdin# 查看git数据库中的对象$ find .git/objects -type -f</code></pre><p>结果为 <code>.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code>，其中 <code>d670460b4b4aece5915caf5c68d12f560a9fe3e4</code>，其中 <code>d670460b4b4aece5915caf5c68d12f560a9fe3e4</code> 就是内容 <code>test content</code> 所对应的 <code>SHA-1</code> 哈希值。上面说到，git对象是键值对，其中这个哈希值就是 <code> key</code>，所对应的 <code>value</code> 为</p><pre><code class="bash">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4 # 输出 test content</code></pre><p>此外，我们也可以查看该文件的类型：</p><pre><code class="bash">$ git cat-file -t d670460b4b4aece5915caf5c68d12f560a9fe3e # 输出 blob</code></pre><p>接下来，我们对一个文件进行简单的版本控制</p><pre><code class="bash">$ echo &quot;version 1&quot; &gt; test.txt$ git hash-object -w test.txt$ find .git/objects -type f# 输出结果.git/objects/83/baae61804e65cc73a7201a7252750c76066a30.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre><p>其中，<code>d670460b4b4aece5915caf5c68d12f560a9fe3e</code> 是我们通过标准输入流所创建的git对象，而 <code>83baae61804e65cc73a7201a7252750c76066a30</code> 是我们刚刚创建的git对象，接下来我们查看该对象的类型和内容：</p><pre><code class="bash">$ git cat-file -t 83baae61804e65cc73a7201a7252750c76066a30 # blob$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 # version 1</code></pre><p>然后，我们对 <code>test.txt</code> 进行修改，并创建git对象</p><pre><code class="bash"># 首先，我们没对test.txt进行修改，直接尝试创建git对象$ git hash-object -w test.txt$ find .git/objects -type f# 结果，跟上边进行对比，发现hash值并未改变，即并未创建git对象.git/objects/83/baae61804e65cc73a7201a7252750c76066a30.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4# 对test.txt内容进行修改，添加 version 2，然后尝试创建git对象$ git hash-object -w test.txt$ find .git/objects -type f# 结果，发现多了一个hash值：0c1e7391ca4e59584f8b773ecdbbb9467eba1547.git/objects/0c/1e7391ca4e59584f8b773ecdbbb9467eba1547.git/objects/83/baae61804e65cc73a7201a7252750c76066a30.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre><p>经过上边的实验，我们发现，git对象创建与文件内容息息相关，因为文件内容不变，hash值也不会变。</p><p><strong>命令总结：</strong></p><ul><li>&#96;&#96;git hash-object &lt;文件路径&gt;&#96;：返回对应文件内容的键值，该键值是一个长度为40个字符的校验和，这是一个SHA-1哈希值</li><li><code>git hash-onject -w &lt;文件路径&gt;</code>：将文件保存，存储在 <code>.git/objects/</code> 下</li><li><code>git cat-file -p &lt;哈希值&gt;</code>：查看对应哈希（也是对应文件）的内容</li><li><code>git cat-file -t &lt;哈希值&gt;</code>：查看该哈希（或者该文件）存储的类型</li></ul><p><strong>问题：</strong></p><ul><li>记住文件每个版本的hash值并不现实</li><li>在git中并没有保存文件名，只是保存了文件内容</li></ul><h5 id="3-2-2-2-tree对象"><a href="#3-2-2-2-tree对象" class="headerlink" title="3.2.2.2 tree对象"></a>3.2.2.2 tree对象</h5><p>树对象能够解决文件名保存的问题，也允许我们将多个文件组织到一起。Git以一种类似于UNIX文件系统的方式存储内容。所有内容均以 树对象和数据对象(git 对象)的形式存储，其中树对象对应了 UNIX 中的目录项（文件+文件夹）， 数据对象(git 对象)则大致上对应文件内容。一个树对象包含了一条或多条记录（每条记录含有一个指向 git 对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息）。一个树对象也可以包含另一个树对象。</p><p><strong>操作：</strong></p><p>向 <code>test.txt</code> 文件中写入 <code>version 1</code>，并将该文件提交到暂存区</p><pre><code class="bash">$ echo &quot;version 1&quot; &gt; test.txt$ git hash-object -w test.txt# 返回hash值：83baae61804e65cc73a7201a7252750c76066a30# 查看暂存区中的内容$ git ls-files -s # 暂存区中目前什么也没有# 给git对象取文件名，并将该记录保存到暂存区（不会保存到git数据库中）$ git update-index --add --cacheinfo 100644 83baae61804e65cc73a7201a7252750c76066a30 test.txt# 将树对象写入到git数据库中$ git write-tree$ find .git/objects -type # 结果.git/objects/83/baae61804e65cc73a7201a7252750c76066a30.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579# 查看树对象的类型和内容$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579 # 100644 blob 83baae61804e65cc73a7201a7252750c76066a30    test.txt</code></pre><p>新增 <code>new.txt</code> ，将 <code>new.txt</code> 和 <code>test.txt</code> 文件的第二个版本（内容为<code>version 2</code>）塞入暂存区，并生成树对象</p><pre><code class="bash"># 编辑test.txt$ git hash-object -w test.txt # 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a$ git update-index --add --cacheinfo 100644 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt$ echo &quot;new file&quot; &gt; new.txt$ git hash-object -w new.txt # fa49b077972391ad58037050f2a75f74e3671e92# 下面这句话等价于 git update-index --add --cacheinfo 100644 fa49b077972391ad58037050f2a75f74e3671e92 new.txt$ git update-index --add new.txt$ git write-tree</code></pre><p>将第一个树对象加入到第二个树对象，使其称为新的树对象</p><pre><code class="bash"># 将第一个树对象加入到第二个树对象，并将第一个树对象改名为 bakgit read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579 git write-tree $ find .git/objects/ -type f# 结果：第一个为之前的第二个树对象.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614.git/objects/83/baae61804e65cc73a7201a7252750c76066a30.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92</code></pre><p>此时，最后的树对象为：</p><img src="/2023/03/27/Git/树对象.png" alt="最终树对象示意图" style="zoom:80%;"><p><strong>命令总结：</strong></p><ul><li><code>git update-index --add --cacheinfo &lt;文件模式&gt; &lt;哈希值&gt; &lt;文件名&gt;</code>：给git对象取文件名，并将该记录保存到暂存区（不会保存到git数据库中）<ul><li>文件模式：100644，普通文件；100755，可执行文件；120000，符号链接</li><li><code>--cacheinfo</code>：因为将要添加的文件位于 Git 数据库中，而不是位于当前目录下，所以需要 <code>--cacheinfo</code></li><li><code>--add</code>：因为此前该文件并不在暂存区中，首次需要<code>--add</code></li></ul></li><li><code>git write-tree</code>：将树对象保存到git数据库中</li><li><code>git update-index --add &lt;文件名&gt;</code>：第一条命令的简单模式，与第一条命令作用一致</li></ul><blockquote><p>注意：当将树对象保存到git数据库中后，暂存区中的内容并不会清空</p></blockquote><h5 id="3-2-2-3-commit对象"><a href="#3-2-2-3-commit对象" class="headerlink" title="3.2.2.3 commit对象"></a>3.2.2.3 commit对象</h5><p>我们可以通过调用 <code>commit-tree</code> 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话 第一次将暂存区做快照就没有父对象）</p><p>接上边树对象的例子，指定第一棵树来创建提交对象</p><pre><code class="bash"># first commit 是提交信息，返回提交对象的hash值：f068d1749b2e60ddb2434d1ce9f29a35f28c6928$ echo &quot;first commit&quot; | git commit-tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579  # 查看提交对象的类型以及内容$ git cat-file -t f068d1749b2e60ddb2434d1ce9f29a35f28c6928 # commit$ git cat-file -p f068d1749b2e60ddb2434d1ce9f29a35f28c6928</code></pre><p>提交对象的内容如下：</p><ul><li>一个顶层树对象，代表当前项目的快照</li><li>用户配置信息，如 <code>user.name</code> 和 <code>user.email</code>，并添加了时间戳</li><li>空行</li><li>提交注释</li></ul><pre><code class="text">tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579author zhliu9802 &lt;zhliu9802@163.com&gt; 1679791369 +0800committer zhliu9802 &lt;zhliu9802@163.com&gt; 1679791369 +0800first commit</code></pre><p>接着，我们创建第二棵树的提交对象</p><pre><code class="bash"># -p：指定父提交对象，即我们上边第一次创建的提交对象的hash值，返回：d3211ccc8180d037de7bfe36e92380ddac2f6a3d$ echo &quot;second commit&quot; | git commit-tree 3c4e9cd789d88d8d89c1073707c3585e41b0e614 -p f068d1749b2e60ddb2434d1ce9f29a35f28c6928# 查看这次提交对象的内容$ git cat-file -p d3211ccc8180d037de7bfe36e92380ddac2f6a3d</code></pre><p>内容如下：</p><pre><code class="text">tree 3c4e9cd789d88d8d89c1073707c3585e41b0e614parent f068d1749b2e60ddb2434d1ce9f29a35f28c6928author zhliu9802 &lt;zhliu9802@163.com&gt; 1679792432 +0800committer zhliu9802 &lt;zhliu9802@163.com&gt; 1679792432 +0800second commit</code></pre><p>命令总结：</p><ul><li><code>echo &lt;message&gt; | git commit-tree &lt;tree对象hash&gt; [-p &lt;父commit对象hash&gt;] </code></li></ul><h2 id="4-Git本地操作（高层命令）"><a href="#4-Git本地操作（高层命令）" class="headerlink" title="4 Git本地操作（高层命令）"></a>4 Git本地操作（高层命令）</h2><h3 id="4-1-工作流程"><a href="#4-1-工作流程" class="headerlink" title="4.1 工作流程"></a>4.1 工作流程</h3><ol><li>创建工作目录，并对工作目录进行修改</li><li><code>git add ./</code>，等价于执行以下两条指令</li></ol><pre><code class="bash"># 将git对象写入git数据库，并在暂存区创建树对象$ git hash-object -w &lt;文件名&gt; # 可能会执行多次，修改了多少个文件就执行多少次$ git update-index --add &lt;文件名&gt;</code></pre><ol start="3"><li><code>git commit -m &quot;注释内容&quot;</code>，等价于执行以下两条指令</li></ol><pre><code class="bash"># 将树对象存入git数据库，并创建commit对象$ git write-tree$ echo &quot;注释内容&quot; | git commit-tree &lt;tree对象hash&gt; [-p &lt;父commit对象hash&gt;]</code></pre><h3 id="4-2-初始化本地仓库"><a href="#4-2-初始化本地仓库" class="headerlink" title="4.2 初始化本地仓库"></a>4.2 初始化本地仓库</h3><p><strong>命令：</strong></p><ul><li><code>git init</code>：初始化仓库，在当前文件夹下会生成一个 <code>.git</code> 目录，并对当前目录开始使用 <code>git</code> 管理</li></ul><p><strong>案例：</strong>在桌面创建 <code>workspace</code> 目录，并对该目录开始使用 <code>git</code> 管理</p><pre><code class="bash">$ mkdir workspace &amp;&amp; cd workspace$ git init</code></pre><h3 id="4-3-新增操作（C）"><a href="#4-3-新增操作（C）" class="headerlink" title="4.3 新增操作（C）"></a>4.3 新增操作（C）</h3><h4 id="4-3-1-暂存文件"><a href="#4-3-1-暂存文件" class="headerlink" title="4.3.1 暂存文件"></a>4.3.1 暂存文件</h4><p><strong>命令：</strong></p><ul><li><code>git add &lt;文件或目录&gt;</code>：将该文件或目录添加到暂存区  ，同时这些文件将被标记为<strong>已暂存（staged）</strong>状态</li><li><code>git add -u</code>：将所有已经被git管理的文件一起提交到暂存区</li><li><code>git ls-files -s</code>：查看暂存区中的内容</li></ul><p><strong>案例：</strong></p><ul><li>在桌面创建 <code>workspace</code> 目录，并对其开始使用 <code>git</code> 管理</li><li>在该目录中创建 <code>a.txt</code> ，写入内容 <code>a.txt v1</code>，查看该文件目前的状态。</li><li>将该文件提交到暂存区，再次查看该文件的状态。</li><li>在 <code>a.txt</code> 中再添加一条注释，加完注释后再次查看该文件的状态</li><li>查看暂存区中文件的修改情况</li><li>查看暂存区中有哪些文件</li></ul><pre><code class="bash">$ mkdir workspace &amp;&amp; cd workspace$ git init$ echo &quot;a.txt v1&quot; &gt; a.txt$ git status$ git add a.txt$ git status$ vim a.txt$ git status$ git diff $ git diff --cached</code></pre><p>执行第一次 <code>git status</code> 时，会出现下图所示的信息，该信息表示 <code>a.txt</code> 还没有提交到暂存区，该文件当前的状态为<strong>已修改（红色）</strong>：</p><img src="/2023/03/27/Git/未暂存文件状态.png" alt="image-20230323222410194" style="zoom:80%;"><p>执行第二次 <code>git status</code> 时，会出现下图所示的信息，该信息表示 <code>a.txt</code> 已经提交到暂存区，但是还未提交到代码库中，该文件当前的状态为<strong>已暂存（绿色）</strong>：</p><img src="/2023/03/27/Git/已暂存未提交文件状态.png" alt="image-20230323222610351" style="zoom:80%;"><p>执行第三次 <code>git status</code> 时，会出现下图所示的信息，根据前两次可知，绿色表示该文件已暂存（<code>stage</code>），红色表示该文件已修改（<code>not staged</code>），一个文件居然同时有两种状态，如果此时我们执行 <code>git commmit</code> 命令，我们会将上次暂存的文件（即没有添加注释的文件）推送至代码库，而不是我们之后修改的文件。为了解决这种情况，我们需要将该文件重新添加到暂存区，即执行 <code>git add a.txt</code>，此时再次查看文件状态，只有已暂存状态（绿色）存在：</p><img src="/2023/03/27/Git/修改暂存文件的文件状态.png" alt="image-20230323223318293" style="zoom:80%;"><h4 id="4-3-2-提交文件"><a href="#4-3-2-提交文件" class="headerlink" title="4.3.2 提交文件"></a>4.3.2 提交文件</h4><p><strong>作用：</strong>将暂存区中的内容提交到版本库</p><p><strong>命令：</strong></p><ul><li><code>git commit </code>：启动文本编辑器以便输入本次提交的说明【当注释过多时，使用这个】</li><li><code>git commit -a -m</code>：跳过使用暂存区域，自动把所有已经跟踪过的文件暂存起来一并提交【必须之前提交过的文件才能使用 <code>-a</code> 参数】</li></ul><pre><code class="bash">$ git commit -m &quot;注释内容&quot;</code></pre><h3 id="4-4-修改操作（U）"><a href="#4-4-修改操作（U）" class="headerlink" title="4.4 修改操作（U）"></a>4.4 修改操作（U）</h3><h4 id="4-4-1-更改文件名"><a href="#4-4-1-更改文件名" class="headerlink" title="4.4.1 更改文件名"></a>4.4.1 更改文件名</h4><p><strong>方法1：</strong></p><pre><code class="bash">$ mv readme readme.md$ git add readme.md$ git rm readme$ git commit -m &quot;重命名readme为readme.md&quot;</code></pre><p><strong>方法2：</strong></p><pre><code class="bash">$ git mv readme readme.txt$ git commit -m &quot;重命名readme为readme.md&quot;</code></pre><h4 id="4-4-2-修改注释"><a href="#4-4-2-修改注释" class="headerlink" title="4.4.2 修改注释"></a>4.4.2 修改注释</h4><ul><li><p><code>git commit --amend</code>：针对最近一次的 <code>commit</code> 的 <code>message</code> 进行修改</p></li><li><p><code>git rebase -i &lt;父节点的hash值&gt;</code>：修改历史 <code>commit</code> 的 <code>message </code>注释</p></li></ul><h3 id="4-5查询操作（R）"><a href="#4-5查询操作（R）" class="headerlink" title="4.5查询操作（R）"></a>4.5查询操作（R）</h3><h4 id="4-5-1-查看文件状态"><a href="#4-5-1-查看文件状态" class="headerlink" title="4.5.1 查看文件状态"></a>4.5.1 查看文件状态</h4><p> <strong>命令：</strong></p><ul><li><code>git status</code>：查看当前目录中文件的状态</li><li><code>git ls-files -s</code>：查看暂存区中的文件</li></ul><p><strong>文件状态：</strong></p><p>在工作目录中的所有文件，只有两种状态：<strong>已跟踪</strong>、<strong>未跟踪</strong></p><ul><li>已跟踪：指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是<strong>已提交</strong>，<strong>已修改</strong>或者<strong>已暂存</strong></li><li>未跟踪：除了已跟踪的文件外，其他都是未跟踪</li></ul><h4 id="4-5-2-查看文件差异"><a href="#4-5-2-查看文件差异" class="headerlink" title="4.5.2 查看文件差异"></a>4.5.2 查看文件差异</h4><ul><li><code>git diff</code>：查看工作区和暂存区之间的文件差异</li><li><code>git diff --staged</code> 或 <code>git diff --cached</code>：查看某个文件当前在暂存区和上次版本库之间的差异【查看哪些修改被暂存了，但是还没被提交】</li><li><code>git diff -- &lt;文件名&gt;</code>：只查看某个文件工作区和暂存区的差别</li><li><code>git diff &lt;分支1/hash&gt; &lt;分支2/hash&gt;</code>：查看两个分支之间的差异</li><li><code>git diff &lt;分支1/hash&gt; &lt;分支2/hash&gt; -- &lt;文件路径&gt;</code>：查看两个分支指定文件之间的差异</li></ul><h4 id="4-5-3-查看版本演进历史"><a href="#4-5-3-查看版本演进历史" class="headerlink" title="4.5.3 查看版本演进历史"></a>4.5.3 查看版本演进历史</h4><ul><li><code>git log --oneline</code> ：只查看<strong>当前分支</strong>的演进历史</li><li><code>git log --oneline &lt;分支名&gt;</code>：只查看指定分支的演进历史</li><li><code>git log --oneline --decorate --graph --all</code>：查看整个项目的分支图</li><li><code>git log -n4 --oneline</code>：查看当前分支前四行的演进历史</li><li><code>git log --all</code>：查看所有分支的演进历史</li><li><code>git help --web log</code>：以网页的形式查看 <code>git log</code> 的帮助手册</li><li><code>git reflog</code>：查看所有的历史记录，只要 <code>HEAD</code> 移动了就会被记录</li><li><code>git log -g</code></li></ul><h3 id="4-9-删除操作（D）"><a href="#4-9-删除操作（D）" class="headerlink" title="4.9 删除操作（D）"></a>4.9 删除操作（D）</h3><p><strong>方式1：</strong>从工作目录手动删除文件</p><pre><code class="bash"># 首先手动从工作目录删除该文件$ git add ./$ git commit -m &quot;del new.txt&quot;</code></pre><p><strong>方式2：</strong></p><pre><code class="bash">$ git rm new.txt$ git commit -m &quot;del new.txt&quot;</code></pre><h2 id="5-git分支操作"><a href="#5-git分支操作" class="headerlink" title="5 git分支操作"></a>5 git分支操作</h2><p>分支就是指向提交对象的指针</p><h3 id="5-1-查看分支"><a href="#5-1-查看分支" class="headerlink" title="5.1 查看分支"></a>5.1 查看分支</h3><ul><li><p><code>git branch</code>：显示所有分支的列表</p></li><li><p><code>git branch -v</code>：查看每一个分支的最后一次提交</p></li><li><p><code>git branch --merged</code>：查看已经合并到当前分支的分支列表</p></li><li><p><code>git branch --no-merged</code>：查看未合并到当前分支的分支列表</p></li></ul><h3 id="5-2-创建分支"><a href="#5-2-创建分支" class="headerlink" title="5.2 创建分支"></a>5.2 创建分支</h3><ul><li><code>git branch &lt;分支名&gt;</code>：新建分支，并指向当前分支所指向的 <code>commit</code> 对象（master分支）</li><li><code>git branch &lt;分支名&gt; &lt;commitHash&gt;</code>：新建一个分支，并使该分支指向指定的commit对象</li><li><code>git branch -b &lt;分支名&gt;</code>：创建并切换分支，即让 <code>HEAD</code> 指向该分支</li></ul><h3 id="5-3-切换分支"><a href="#5-3-切换分支" class="headerlink" title="5.3 切换分支"></a>5.3 切换分支</h3><p>切换分支就是使 <code>HEAD</code> 指向另外一个分支</p><ul><li><code>git checkout &lt;分支名&gt;</code></li></ul><p>切换分支会改变三个东西：</p><ul><li>HEAD</li><li>暂存区  <code>git ls-files -s</code></li><li>工作目录</li></ul><blockquote><p>注意：切换分支之前，务必保证当前分支是<strong>已提交</strong>状态，使用 <code>git status</code> 查看文件当前状态，否则会污染master分支。</p></blockquote><p>坑点：</p><ul><li><p>在切换分支时，如果当前分支有<strong>新文件未暂存</strong>或<strong>未提交</strong>，可以切换分支，但是 <code>git</code> 会默认带到所切换的分支上。</p></li><li><p>在切换分支时，如果当前分支修改了已经提交的内容且修改后没有进行提交，则不允许切换分支。</p></li></ul><h3 id="5-4-删除分支"><a href="#5-4-删除分支" class="headerlink" title="5.4 删除分支"></a>5.4 删除分支</h3><ul><li><code>git branch -D &lt;分支名/hash值&gt;</code>：强制删除分支，如果分支上的内容没有被合并，就需要强制删除</li><li><code>git branch -d &lt;分支名/hash值&gt;</code>：删除分支，只有合并后的分支（空分支）才可以这样删除</li></ul><blockquote><p>注意：不能删除当前所在分支，必须切到 <code>master</code> 分支后，再删除</p></blockquote><h3 id="5-5-合并分支"><a href="#5-5-合并分支" class="headerlink" title="5.5 合并分支"></a>5.5 合并分支</h3><h4 id="5-5-1-快进合并"><a href="#5-5-1-快进合并" class="headerlink" title="5.5.1 快进合并"></a>5.5.1 快进合并</h4><pre><code class="bash">$ git chechout master$ git merge &lt;分支名/commitHash&gt;  # 快进 fast-forwarding合并</code></pre><h4 id="5-5-2-典型合并"><a href="#5-5-2-典型合并" class="headerlink" title="5.5.2 典型合并"></a>5.5.2 典型合并</h4><pre><code class="bash">$ git checkout master$ git merge &lt;分支名/commitHash&gt; # 此时命令行会出现合并冲突，比如a.txt合并冲突$ vim a.txt # 修改a.txt的内容，分析哪些代码留，哪些代码删，以解决冲突$ git add ./$ git commit -m &quot;消息&quot;</code></pre><h2 id="6-git存储"><a href="#6-git存储" class="headerlink" title="6 git存储"></a>6 git存储</h2><p>当我们在开发中被临时指派了任务，而且目前的任务还未完成，我们该怎么做？</p><h3 id="6-1-存储"><a href="#6-1-存储" class="headerlink" title="6.1 存储"></a>6.1 存储</h3><p>将当前任务添加到 <code>stash</code> 列表【栈】上</p><pre><code class="bash">$ git stash</code></pre><h3 id="6-2-查看存储"><a href="#6-2-查看存储" class="headerlink" title="6.2 查看存储"></a>6.2 查看存储</h3><p>查看 <code>stash</code> 列表</p><pre><code class="bash">$ git stash list </code></pre><h3 id="6-3-恢复存储"><a href="#6-3-恢复存储" class="headerlink" title="6.3 恢复存储"></a>6.3 恢复存储</h3><pre><code class="bash">$ git stash apply # 恢复上一次任务，但不会从stash列表中删除$ git stash apply &lt;commitHash&gt; # 恢复指定任务$ git stash pop # 恢复上次任务，并将该任务从 stash 列表中删除</code></pre><h3 id="6-4-删除存储"><a href="#6-4-删除存储" class="headerlink" title="6.4 删除存储"></a>6.4 删除存储</h3><pre><code class="bash">$ git stash list # 查看存储列表$ git stash drop stash@&#123;0&#125; # 删除指定序号为stash@&#123;0&#125;的存储项</code></pre><h2 id="7-git撤销"><a href="#7-git撤销" class="headerlink" title="7 git撤销"></a>7 git撤销</h2><p>撤销修改就是查看输入 <code>git status</code> 后的提示信息</p><h3 id="7-1-撤销工作区修改"><a href="#7-1-撤销工作区修改" class="headerlink" title="7.1 撤销工作区修改"></a>7.1 撤销工作区修改</h3><p>注意：撤销操作仅对已经提交的文件有效</p><p>下面的撤销命令可能会更新，注意使用 <code>git status</code> 查看系统提示的最新命令</p><ul><li><code>git restore &lt;文件名&gt;</code>：撤销修改</li></ul><h3 id="7-2-撤销暂存区的暂存"><a href="#7-2-撤销暂存区的暂存" class="headerlink" title="7.2 撤销暂存区的暂存"></a>7.2 撤销暂存区的暂存</h3><ul><li><p><code>git restore --staged &lt;file&gt;</code>：将暂存区中指定文件恢复成和HEAD一致</p></li><li><p><code>git reset --mixed HEAD &lt;filename&gt;</code>：将暂存区中指定文件恢复成和HEAD一致，可以简写成 <code>git reset HEAD &lt;filename&gt;</code> 或 <code>git reset &lt;filename&gt;</code></p></li></ul><h3 id="7-3-撤销版本库的提交"><a href="#7-3-撤销版本库的提交" class="headerlink" title="7.3 撤销版本库的提交"></a>7.3 撤销版本库的提交</h3><ol><li>内容写错了，需要重新提交</li></ol><pre><code class="bash"># 重新编辑写错的文档$ git add  ./$ git commit -m &quot;xxxxx&quot;</code></pre><ol start="2"><li>注释写错了，只能修改最近一次提交的注释</li></ol><pre><code class="bash">$ git commit --amend</code></pre><h2 id="8-git重置"><a href="#8-git重置" class="headerlink" title="8 git重置"></a>8 git重置</h2><p>假设当前的分支图如下所示：</p><img src="/2023/03/27/Git/git重置初始状态分支图.png" alt="git重置初始状态分支图" style="zoom:80%;"><h3 id="8-1-软重置"><a href="#8-1-软重置" class="headerlink" title="8.1 软重置"></a>8.1 软重置</h3><p>经过软重置之后，<code>HEAD</code> 以及所指向的分支都会进行改变，这就导致版本库的变化。</p><p>软重置本质上撤销了上一次的 <code>commit</code> 操作。</p><pre><code class="bash">$ git reset --soft HEAD~$ git reset --soft HEAD~2</code></pre><p>当执行完 <code>git reset --soft HEAD~</code> 之后，分支图如下所示：</p><img src="/2023/03/27/Git/软重置后分支图.png" alt="软重置后分支图" style="zoom:80%;"><h3 id="8-2-mix重置"><a href="#8-2-mix重置" class="headerlink" title="8.2 mix重置"></a>8.2 mix重置</h3><p>会撤销上一次的 <code>commit</code>，而且还会取消暂存的东西</p><ul><li>不带文件名：撤销暂存区的所有</li></ul><pre><code class="bash">$ git reset --mixed HEAD~$ git reset HEAD~</code></pre><ul><li>带文件名：撤销暂存区指定文件，本质上就是将 <code>HEAD</code> 中的内容复制到 <code>Index</code> 中</li></ul><pre><code class="bash">$ git reset &lt;filename&gt;</code></pre><img src="/2023/03/27/Git/mix重置（不带路径）后分支图.png" alt="mix重置（不带路径）后分支图" style="zoom:80%;"><blockquote><p>注意：只有 <code>--mixed</code> 选项后才能加 <code>&lt;filename&gt;</code>，指定某一个文件回退</p></blockquote><h3 id="8-3-硬重置【危险操作】"><a href="#8-3-硬重置【危险操作】" class="headerlink" title="8.3 硬重置【危险操作】"></a>8.3 硬重置【危险操作】</h3><p>硬重置会重置工作目录中的内容，导致无法恢复！</p><img src="/2023/03/27/Git/硬重置后分支图.png" alt="硬重置后分支图" style="zoom:80%;"><h2 id="9-数据恢复"><a href="#9-数据恢复" class="headerlink" title="9 数据恢复"></a>9 数据恢复</h2><pre><code class="bash"># 首先使用下面命令，查看想要恢复到哪个提交对象时$ git reflog# 然后在这个提交对象上创建分支$ git branch &lt;分支名&gt; &lt;commitHash&gt;</code></pre><h2 id="10-tag"><a href="#10-tag" class="headerlink" title="10 tag"></a>10 tag</h2><p>Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。</p><h3 id="10-1-列出标签"><a href="#10-1-列出标签" class="headerlink" title="10.1 列出标签"></a>10.1 列出标签</h3><pre><code class="bash">$ git tag$ git tag -l &#39;1.8.5*&#39;</code></pre><h3 id="10-2-创建标签"><a href="#10-2-创建标签" class="headerlink" title="10.2 创建标签"></a>10.2 创建标签</h3><ul><li>轻量标签：很像一个不会改变的分支 - 它只是一个特定提交的引用</li></ul><pre><code class="bash">$ git tag &lt;tagname&gt;$ git tag &lt;tagname&gt; &lt;commitHash&gt;</code></pre><ul><li>附注标签：存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子 邮件地址、日期时间；还有一个标签信息。</li></ul><pre><code class="bash">$ git tag -a v1.4$ git tag -a v1.4 commitHash$ git tag -a v1.4 commitHash -m &#39;my version 1.4&#39;</code></pre><h3 id="10-3-查看特定标签"><a href="#10-3-查看特定标签" class="headerlink" title="10.3 查看特定标签"></a>10.3 查看特定标签</h3><pre><code class="bash">$ git show &lt;tagname&gt;</code></pre><h3 id="10-4-远程标签"><a href="#10-4-远程标签" class="headerlink" title="10.4 远程标签"></a>10.4 远程标签</h3><h3 id="10-5-删除标签"><a href="#10-5-删除标签" class="headerlink" title="10.5 删除标签"></a>10.5 删除标签</h3><pre><code class="bash">$ git tag -d &lt;tagname&gt;</code></pre><h3 id="10-6-检出标签"><a href="#10-6-检出标签" class="headerlink" title="10.6 检出标签"></a>10.6 检出标签</h3><p>如果你想查看某个标签所指向的文件版本，可以使用 <code>git checkout</code> 命令。虽然说这会使你的仓库处于“分离头指针（detacthed HEAD）”状态。在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非访问确切的提交哈希。因此， 如果你需要进行更改——比如说你正在修复旧版本的错误——这通常需要创建一个新分支：</p><pre><code class="bash">$ git checkout -b &lt;tagname&gt;</code></pre><p>会出现<strong>分离头指针</strong>的情况，解决方法是：<strong>创建新的分支，让HEAD指向该分支</strong></p><h2 id="11-备份"><a href="#11-备份" class="headerlink" title="11 备份"></a>11 备份</h2><h2 id="11-远程仓库【第二大章】"><a href="#11-远程仓库【第二大章】" class="headerlink" title="11 远程仓库【第二大章】"></a>11 远程仓库【第二大章】</h2><p>为了能在任意 Git 项目上团队协作，你需要知道如何管理自己的远程仓库。 <strong>远程仓库</strong>是指托管在因特网或其他网络中的你的项目的版本库。你可以有好几个远程仓库， 通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、 管理不同的远程分支并定义它们是否被跟踪等等。</p><h3 id="11-1-远程协作的基本流程"><a href="#11-1-远程协作的基本流程" class="headerlink" title="11.1 远程协作的基本流程"></a>11.1 远程协作的基本流程</h3><h4 id="11-1-1-项目经理创建远程仓库"><a href="#11-1-1-项目经理创建远程仓库" class="headerlink" title="11.1.1 项目经理创建远程仓库"></a>11.1.1 项目经理创建远程仓库</h4><h4 id="11-1-2-项目经理创建本地仓库-amp-amp-配置用户信息"><a href="#11-1-2-项目经理创建本地仓库-amp-amp-配置用户信息" class="headerlink" title="11.1.2 项目经理创建本地仓库&amp;&amp;配置用户信息"></a>11.1.2 项目经理创建本地仓库&amp;&amp;配置用户信息</h4><pre><code class="bash">$ git init$ git config user.name &quot;damu&quot;$ git config user.email &quot;dama@qq.com&quot;$ echo &quot;betterdamu.txt v1&quot; &gt; betterdamu.txt$ git add ./$ git commit -m &quot;1 commit for taobao v1 from damu&quot;</code></pre><h4 id="11-1-3-项目经理为远程仓库配置别名"><a href="#11-1-3-项目经理为远程仓库配置别名" class="headerlink" title="11.1.3 项目经理为远程仓库配置别名"></a>11.1.3 项目经理为远程仓库配置别名</h4><ul><li><p><code>git remote add &lt;仓库别名&gt; &lt;url&gt;</code>：添加一个新的远程 <code>Git</code> 仓库，同时为这个仓库起一个好记的名字</p></li><li><p><code>git remote -v</code>：查看 <code>Git</code> 别名与远程仓库的对应关系</p></li><li><p><code>git remote show &lt;仓库别名&gt;</code>：</p></li><li><p><code>git remote &lt;old_name&gt; &lt;new_name&gt;</code>：</p></li><li><p><code>git remote rm &lt;仓库别名&gt;</code>：</p></li></ul><pre><code class="bash">$ git remote -v$ git remote add taobao https://github.com/zhliu9802/test.git$ git remote -v$ git remote show taobao </code></pre><h4 id="11-1-4-项目经理推送本地项目到远程仓库"><a href="#11-1-4-项目经理推送本地项目到远程仓库" class="headerlink" title="11.1.4 项目经理推送本地项目到远程仓库"></a>11.1.4 项目经理推送本地项目到远程仓库</h4><ul><li><code>git push &lt;远程仓库别名&gt; &lt;本地分支名&gt;</code>：将本地项目的 <code>本地分支</code> 推送到 <code>仓库别名</code> 服务器</li></ul><pre><code class="bash">$ git push taobao master</code></pre><h4 id="11-1-5-成员克隆远程仓库到本地"><a href="#11-1-5-成员克隆远程仓库到本地" class="headerlink" title="11.1.5 成员克隆远程仓库到本地"></a>11.1.5 成员克隆远程仓库到本地</h4><ul><li>默认会生成一个 <code>origin</code> 的远程仓库别名</li><li>只有在<strong>克隆</strong>的时候，本地分支 <code>master</code> 与远程跟踪分支 <code>&lt;远程仓库别名&gt;/master</code> 是有同步关系的，因此推送的时候可以直接使用 <code>git push</code></li></ul><pre><code class="bash">$ git clone &lt;url&gt;# 在clone时将远程仓库进行命名$ git clone -o &lt;远程仓库别名&gt;</code></pre><h4 id="11-1-6-项目经理邀请成员加入团队"><a href="#11-1-6-项目经理邀请成员加入团队" class="headerlink" title="11.1.6 项目经理邀请成员加入团队"></a>11.1.6 项目经理邀请成员加入团队</h4><h4 id="11-1-7-成员推送提交到远程仓库"><a href="#11-1-7-成员推送提交到远程仓库" class="headerlink" title="11.1.7 成员推送提交到远程仓库"></a>11.1.7 成员推送提交到远程仓库</h4><ul><li><code>git push &lt;远程仓库别名&gt; &lt;本地分支名&gt;</code></li></ul><pre><code class="bash"># 成员工作$ git add ./$ git commit -m &quot;&quot;$ git push &lt;远程仓库别名&gt; &lt;本地分支名&gt;</code></pre><h4 id="11-1-8-项目经理更新成员提交的内容"><a href="#11-1-8-项目经理更新成员提交的内容" class="headerlink" title="11.1.8 项目经理更新成员提交的内容"></a>11.1.8 项目经理更新成员提交的内容</h4><pre><code class="bash"># 将远程仓库中的更新拉取到远程分支上，此时本地分支上还没有更新$ git fetch &lt;远程仓库名&gt;# 切换到远程分支，可以查看更新内容$ git checkout &lt;远程仓库名&gt;/&lt;分支名&gt;# 切换到本地分支$ git checkout &lt;本地分支名&gt;# 合并$ git merge &lt;远程仓库名&gt;/&lt;分支名&gt;</code></pre><h3 id="11-2-本地分支与远程跟踪分支建立对应关系"><a href="#11-2-本地分支与远程跟踪分支建立对应关系" class="headerlink" title="11.2 本地分支与远程跟踪分支建立对应关系"></a>11.2 本地分支与远程跟踪分支建立对应关系</h3><h4 id="11-2-1-成员推送提交到远程仓库时"><a href="#11-2-1-成员推送提交到远程仓库时" class="headerlink" title="11.2.1 成员推送提交到远程仓库时"></a>11.2.1 成员推送提交到远程仓库时</h4><pre><code class="bash">$ git branch -u &lt;远程仓库别名&gt;/&lt;远程仓库的分支名&gt;  # 将本地当前分支与远程跟踪分支建立对应关系，说明本地已经创建了分支$ git checkout -b &lt;本地分支名&gt; &lt;远程仓库别名&gt;/&lt;远程仓库的分支名&gt; # 创建本地分支，并与远程跟踪分支建立对应关系# 创建本地分支，并与远程跟踪分支建立对应关系，此时本地分支名与远程跟踪分支名相同。注意有时需要先执行 git fetch &lt;远程仓库别名&gt;$ git checkout --track &lt;远程仓库别名&gt;/&lt;远程仓库的分支名&gt;  # 查看对应关系$ git branch -vv$ git push # 建立关系之后可以不指定远程仓库别名和本地分支名，直接推送$ git branch --set-upstream-to</code></pre><h4 id="11-2-2-项目经理更新成员提交的内容时"><a href="#11-2-2-项目经理更新成员提交的内容时" class="headerlink" title="11.2.2 项目经理更新成员提交的内容时"></a>11.2.2 项目经理更新成员提交的内容时</h4><pre><code class="bash">$ git branch -u &lt;远程仓库别名&gt;/&lt;远程仓库的分支名&gt; # 将本地当前分支与远程跟踪分支建立对应关系# 查看对应关系$ git branch -vv$ git pull # 直接拉取</code></pre><h3 id="11-2-冲突"><a href="#11-2-冲突" class="headerlink" title="11.2 冲突"></a>11.2 冲突</h3><p>本地冲突：典型合并的时候</p><p>远程协作冲突：</p><ul><li>同时push了同一个文件，且文件内容不同：解决方法：<code>git pull</code> 然后进行修改</li><li>pull的时候【基本不会出现】</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
